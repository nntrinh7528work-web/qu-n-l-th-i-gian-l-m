==================================================
FILE: app.py
==================================================
Ôªø# -*- coding: utf-8 -*-
"""
·ª®ng D·ª•ng Qu·∫£n L√Ω Gi·ªù L√†m
========================
·ª®ng d·ª•ng Streamlit ƒë·ªÉ qu·∫£n l√Ω gi·ªù l√†m vi·ªác, t√≠nh to√°n gi·ªù l√†m th√™m,
v√† t√πy ch·ªânh l·ªãch l√†m vi·ªác.

T√°c gi·∫£: AI Assistant
Ng√¥n ng·ªØ: Ti·∫øng Vi·ªát
"""

# Thi·∫øt l·∫≠p UTF-8 encoding cho Windows
import sys
import os
os.environ['PYTHONIOENCODING'] = 'utf-8'
try:
    if sys.stdout.encoding != 'utf-8':
        sys.stdout.reconfigure(encoding='utf-8')
    if sys.stderr.encoding != 'utf-8':
        sys.stderr.reconfigure(encoding='utf-8')
except Exception:
    pass

import streamlit as st
import pandas as pd
import plotly.express as px
import plotly.graph_objects as go
from datetime import datetime, date, time, timedelta
import calendar
from io import BytesIO

# Import c√°c module n·ªôi b·ªô
import db_wrapper as db  # T·ª± ƒë·ªông ch·ªçn Supabase ho·∫∑c SQLite
import calculations as calc
import user_auth as auth

# ==================== C·∫§U H√åNH TRANG ====================

st.set_page_config(
    page_title="Work Tracker Pro",
    page_icon="üöÄ",
    layout="wide",
    initial_sidebar_state="collapsed"
)

# ==================== CSS T√ôY CH·ªàNH (GEN Z STYLE) ====================

st.markdown("""
<style>
    @import url('https://fonts.googleapis.com/css2?family=Outfit:wght@400;600;800&display=swap');

    html, body, [class*="css"] {
        font-family: 'Outfit', sans-serif;
    }

    /* Gradient Background Text */
    .main-header {
        font-size: 3rem;
        font-weight: 800;
        background: linear-gradient(to right, #FF0080, #FF8C00, #40E0D0);
        -webkit-background-clip: text;
        -webkit-text-fill-color: transparent;
        text-align: center;
        margin-bottom: 0.5rem;
        text-transform: uppercase;
        letter-spacing: 2px;
    }

    /* Modern Cards */
    .stat-card {
        background: rgba(255, 255, 255, 0.05);
        backdrop-filter: blur(10px);
        border: 1px solid rgba(255, 255, 255, 0.1);
        padding: 1.5rem;
        border-radius: 24px;
        color: white;
        text-align: center;
        transition: transform 0.3s ease, box-shadow 0.3s ease;
        box-shadow: 0 4px 20px rgba(0, 0, 0, 0.2);
    }
    
    .stat-card:hover {
        transform: translateY(-5px);
        box-shadow: 0 10px 30px rgba(0, 0, 0, 0.3);
        border-color: rgba(255, 255, 255, 0.3);
    }

    .stat-card h3 {
        margin: 0;
        font-size: 2.2rem;
        font-weight: 800;
        background: linear-gradient(45deg, #fff, #ccc);
        -webkit-background-clip: text;
        -webkit-text-fill-color: transparent;
    }
    
    .stat-card p {
        margin-top: 5px;
        font-size: 1rem;
        font-weight: 600;
        opacity: 0.8;
        text-transform: uppercase;
        letter-spacing: 1px;
    }

    /* Result Box Styled */
    .result-box {
        background: #1E1E2E; /* Dark Indigo */
        border: 2px solid #3B82F6;
        border-radius: 20px;
        padding: 1.5rem;
        margin: 1rem 0;
        box-shadow: 0 0 15px rgba(59, 130, 246, 0.3);
    }
    
    .result-box h4 {
        color: #60A5FA;
        font-size: 1.2rem;
        text-transform: uppercase;
    }

    /* Buttons */
    .stButton button {
        border-radius: 12px;
        font-weight: 700;
        text-transform: uppercase;
        letter-spacing: 1px;
        transition: all 0.3s ease;
    }
    
    .stButton button:hover {
        transform: scale(1.02);
        box-shadow: 0 5px 15px rgba(0,0,0,0.2);
    }

    /* Calendar Cells */
    .cal-cell {
        border-radius: 16px;
        padding: 12px;
        text-align: center;
        margin: 4px;
        transition: all 0.2s cubic-bezier(0.4, 0, 0.2, 1);
        cursor: pointer;
    }
    
    .cal-cell:hover {
        transform: scale(1.1) rotate(2deg);
        z-index: 10;
    }
    
    .cal-cell.worked {
        background: linear-gradient(135deg, #10B981 0%, #059669 100%);
        box-shadow: 0 4px 12px rgba(16, 185, 129, 0.4);
        border: none;
        color: white;
    }
    
    .cal-cell.holiday {
        background: linear-gradient(135deg, #EF4444 0%, #DC2626 100%);
        box-shadow: 0 4px 12px rgba(239, 68, 68, 0.4);
        border: none;
        color: white;
    }
    
    .cal-day-num {
        font-weight: 800;
        font-size: 1.2rem;
    }
    
    /* Tabs */
    .stTabs [data-baseweb="tab-list"] {
        gap: 1rem;
        background: rgba(255,255,255,0.05);
        padding: 10px;
        border-radius: 20px;
    }
    
    .stTabs [data-baseweb="tab"] {
        height: 50px;
        border-radius: 15px;
        font-weight: 700;
        font-size: 1rem;
        border: none !important;
    }
    
    .stTabs [aria-selected="true"] {
        background: linear-gradient(90deg, #8B5CF6, #EC4899);
        color: white !important;
        box-shadow: 0 4px 15px rgba(236, 72, 153, 0.4);
    }
</style>
""", unsafe_allow_html=True)

# ==================== KI·ªÇM TRA ƒêƒÇNG NH·∫¨P ====================

# Th·ª≠ Auto-login t·ª´ cookie
auth.check_auto_login()

# Hi·ªÉn th·ªã trang ƒëƒÉng nh·∫≠p n·∫øu ch∆∞a ƒëƒÉng nh·∫≠p
if not auth.is_logged_in():
    auth.show_login_page()
    st.stop()

# ƒê√£ ƒëƒÉng nh·∫≠p - kh·ªüi t·∫°o database cho user
db.init_database()

# Hi·ªÉn th·ªã th√¥ng tin user ·ªü sidebar
auth.show_user_info_sidebar()

# ==================== HEADER ====================

st.markdown('<h1 class="main-header">‚ú® Qu·∫£n L√Ω Gi·ªù L√†m üöÄ</h1>', unsafe_allow_html=True)

# ==================== DASHBOARD T·ªîNG QUAN ====================

# L·∫•y d·ªØ li·ªáu th√°ng hi·ªán t·∫°i
current_month = date.today().month
current_year = date.today().year
month_start = date(current_year, current_month, 1)

# L·∫•y t·∫•t c·∫£ ca l√†m vi·ªác trong th√°ng
all_shifts_month = db.get_shifts_by_range(month_start, date.today())
all_jobs = db.get_all_jobs()
job_map_dashboard = {j['id']: j for j in all_jobs}

# T√≠nh t·ªïng
total_hours_month = 0
total_salary_month = 0
work_days_set = set()

for shift in all_shifts_month:
    hours = shift.get('total_hours', 0)
    job_id = shift.get('job_id', 0)
    hourly_rate = job_map_dashboard.get(job_id, {}).get('hourly_rate', 0)
    
    total_hours_month += hours
    total_salary_month += hours * hourly_rate
    work_days_set.add(shift.get('work_date'))

total_days_month = len(work_days_set)

# Hi·ªÉn th·ªã Dashboard
col_d1, col_d2, col_d3, col_d4 = st.columns(4)

with col_d1:
    st.markdown(f"""
    <div class="stat-card" style="background: linear-gradient(135deg, #FF0080 0%, #7928CA 100%);">
        <h3>üìÖ {total_days_month}</h3>
        <p>Ng√†y l√†m</p>
    </div>
    """, unsafe_allow_html=True)

with col_d2:
    st.markdown(f"""
    <div class="stat-card" style="background: linear-gradient(135deg, #4AF699 0%, #12B886 100%);">
        <h3>‚è±Ô∏è {total_hours_month:.1f}h</h3>
        <p>T·ªïng gi·ªù</p>
    </div>
    """, unsafe_allow_html=True)

with col_d3:
    st.markdown(f"""
    <div class="stat-card" style="background: linear-gradient(135deg, #FFD700 0%, #FFA500 100%);">
        <h3>üí∏ {total_salary_month:,.0f}</h3>
        <p>L∆∞∆°ng (Yen)</p>
    </div>
    """, unsafe_allow_html=True)

with col_d4:
    avg_per_day = total_salary_month / total_days_month if total_days_month > 0 else 0
    st.markdown(f"""
    <div class="stat-card" style="background: linear-gradient(135deg, #00C6FB 0%, #005BEA 100%);">
        <h3>üî• {avg_per_day:,.0f}</h3>
        <p>TB/ng√†y</p>
    </div>
    """, unsafe_allow_html=True)

st.markdown("<br>", unsafe_allow_html=True)

# ==================== TABS ====================

tab1, tab2, tab3, tab4 = st.tabs([
    "üéÆ Nh·∫≠p Gi·ªù", 
    "üìÖ L·ªãch L√†m", 
    "üìà B√°o C√°o", 
    "‚öôÔ∏è C√†i ƒê·∫∑t"
])

# ==================== TAB 1: NH·∫¨P GI·ªú L√ÄM ====================

with tab1:
    st.header("üéÆ Nh·∫≠p Gi·ªù L√†m Vi·ªác")
    
    # ==================== QUICK ENTRY MODE ====================
    st.markdown("### ‚ö° Quick Entry - Log Nhanh")
    
    # L·∫•y danh s√°ch c√¥ng vi·ªác cho quick entry
    quick_jobs = db.get_all_jobs()
    quick_job_map = {j['id']: j for j in quick_jobs}
    
    if quick_jobs:
        quick_col1, quick_col2, quick_col3, quick_col4 = st.columns(4)
        
        # L·∫•y job ƒë·∫ßu ti√™n l√†m m·∫∑c ƒë·ªãnh
        default_job = quick_jobs[0] if quick_jobs else None
        
        with quick_col1:
            if st.button("‚òÄÔ∏è Ca S√°ng 8h\n(8:00-17:00)", use_container_width=True, key="quick_morning"):
                if default_job:
                    shift_id = db.add_work_shift(
                        work_date=date.today(),
                        shift_name="Ca S√°ng",
                        start_time="08:00",
                        end_time="17:00",
                        break_hours=1.0,
                        total_hours=8.0,
                        notes="Quick Entry",
                        job_id=default_job['id']
                    )
                    if shift_id > 0:
                        st.success("‚úÖ ƒê√£ log ca s√°ng 8h!")
                        st.rerun()
        
        with quick_col2:
            if st.button("üåô Ca T·ªëi 8h\n(17:00-02:00)", use_container_width=True, key="quick_evening"):
                if default_job:
                    shift_id = db.add_work_shift(
                        work_date=date.today(),
                        shift_name="Ca T·ªëi",
                        start_time="17:00",
                        end_time="02:00",
                        break_hours=1.0,
                        total_hours=8.0,
                        notes="Quick Entry",
                        job_id=default_job['id']
                    )
                    if shift_id > 0:
                        st.success("‚úÖ ƒê√£ log ca t·ªëi 8h!")
                        st.rerun()
        
        with quick_col3:
            if st.button("‚è∞ Part-time 4h\n(17:00-21:00)", use_container_width=True, key="quick_parttime"):
                if default_job:
                    shift_id = db.add_work_shift(
                        work_date=date.today(),
                        shift_name="Part-time",
                        start_time="17:00",
                        end_time="21:00",
                        break_hours=0.0,
                        total_hours=4.0,
                        notes="Quick Entry",
                        job_id=default_job['id']
                    )
                    if shift_id > 0:
                        st.success("‚úÖ ƒê√£ log part-time 4h!")
                        st.rerun()
        
        with quick_col4:
            if st.button("üî• Full Day 10h\n(8:00-19:00)", use_container_width=True, key="quick_fullday"):
                if default_job:
                    shift_id = db.add_work_shift(
                        work_date=date.today(),
                        shift_name="Full Day",
                        start_time="08:00",
                        end_time="19:00",
                        break_hours=1.0,
                        total_hours=10.0,
                        notes="Quick Entry",
                        job_id=default_job['id']
                    )
                    if shift_id > 0:
                        st.success("‚úÖ ƒê√£ log full day 10h!")
                        st.rerun()
        
        st.caption(f"üí° Quick Entry s·∫Ω log v√†o **{default_job['job_name']}** cho **h√¥m nay**")
    
    st.markdown("---")
    
    # ==================== NH·∫¨P CHI TI·∫æT ====================
    st.markdown("### üìù Nh·∫≠p Chi Ti·∫øt")
    
    # Ch·ªçn ng√†y
    work_date = st.date_input(
        "üìÖ Ch·ªçn ng√†y l√†m vi·ªác:",
        value=date.today(),
        format="DD/MM/YYYY",
        key="main_work_date"
    )
    
    # Ki·ªÉm tra ng√†y ngh·ªâ
    is_hol, hol_desc = db.is_holiday(work_date)
    if is_hol:
        st.warning(f"‚ö†Ô∏è Ng√†y n√†y l√† ng√†y ngh·ªâ: **{hol_desc}**")
    
    # L·∫•y c√°c ca l√†m vi·ªác hi·ªán c√≥
    existing_shifts = db.get_shifts_by_date(work_date)
    standard_hours = db.get_standard_hours()
    total_hours_day = 0  # Kh·ªüi t·∫°o bi·∫øn
    
    # Hi·ªÉn th·ªã c√°c ca ƒë√£ c√≥
    if existing_shifts:
        st.subheader(f"üìå C√°c Ca L√†m Vi·ªác Ng√†y {work_date.strftime('%d/%m/%Y')}")
        
        # T√≠nh t·ªïng gi·ªù v√† l∆∞∆°ng
        total_hours_day = sum(s['total_hours'] for s in existing_shifts)
        
        # T√≠nh l∆∞∆°ng ∆∞·ªõc t√≠nh cho ng√†y n√†y
        all_jobs = db.get_all_jobs()
        job_map = {j['id']: j for j in all_jobs}
        total_salary_day = 0
        
        for shift in existing_shifts:
            job_id = shift.get('job_id', 1)
            if job_id in job_map:
                hourly_rate = job_map[job_id]['hourly_rate']
                total_salary_day += shift['total_hours'] * hourly_rate
        
        # Hi·ªÉn th·ªã metrics
        col_m1, col_m2, col_m3 = st.columns(3)
        with col_m1:
            st.metric("üéØ S·ªë ca", f"{len(existing_shifts)} ca")
        with col_m2:
            st.metric("‚åõ T·ªïng gi·ªù", calc.format_hours(total_hours_day))
        with col_m3:
            st.metric("üíù L∆∞∆°ng ng√†y", f"{total_salary_day:,.0f} Yen")
        
        st.markdown("---")
        
        # Hi·ªÉn th·ªã t·ª´ng ca v·ªõi th√¥ng tin l∆∞∆°ng
        for i, shift in enumerate(existing_shifts):
            job_id = shift.get('job_id', 1)
            job_name = job_map.get(job_id, {}).get('job_name', 'N/A')
            hourly_rate = job_map.get(job_id, {}).get('hourly_rate', 0)
            shift_salary = shift['total_hours'] * hourly_rate
            
            with st.expander(f"üåü {shift['shift_name']} - {job_name} ({shift['total_hours']}h = {shift_salary:,.0f} Yen)", expanded=False):
                col_info, col_action = st.columns([3, 1])
                
                with col_info:
                    st.write(f"**N∆°i l√†m:** {job_name}")
                    st.write(f"**Th·ªùi gian:** {shift['start_time']} - {shift['end_time']}")
                    st.write(f"**Ngh·ªâ:** {shift['break_hours']} gi·ªù")
                    st.write(f"**T·ªïng gi·ªù:** {calc.format_hours(shift['total_hours'])}")
                    st.write(f"**L∆∞∆°ng:** {shift_salary:,.0f} Yen ({hourly_rate:,.0f} Yen/h)")
                    if shift['notes']:
                        st.write(f"**Ghi ch√∫:** {shift['notes']}")
                
                with col_action:
                    if st.button("üóëÔ∏è X√≥a", key=f"del_shift_{shift['id']}", use_container_width=True):
                        if db.delete_work_shift(shift['id']):
                            st.success("ƒê√£ x√≥a ca!")
                            st.rerun()
                        else:
                            st.error("L·ªói khi x√≥a!")
        
        st.markdown("---")
    
    # Form th√™m ca m·ªõi
    st.subheader("‚ú® Th√™m Ca L√†m Vi·ªác M·ªõi")
    
    col1, col2 = st.columns([1, 1])
    
    with col1:
        # L·∫•y danh s√°ch c√¥ng vi·ªác
        all_jobs = db.get_all_jobs()
        job_map = {j['id']: j for j in all_jobs}
        
        # T·∫°o danh s√°ch hi·ªÉn th·ªã: B·ªánh vi·ªán v√† Kombini tr∆∞·ªõc, c√°c c√¥ng vi·ªác kh√°c sau
        display_jobs = []
        
        # T√¨m B·ªánh vi·ªán v√† Kombini
        for name in ['B·ªánh vi·ªán', 'Kombini']:
            for job in all_jobs:
                if job['job_name'] == name:
                    display_jobs.append(job)
                    break
        
        # Th√™m c√°c c√¥ng vi·ªác kh√°c (kh√¥ng ph·∫£i B·ªánh vi·ªán, Kombini, C√¥ng vi·ªác ch√≠nh)
        for job in all_jobs:
            if job['job_name'] not in ['B·ªánh vi·ªán', 'Kombini', 'C√¥ng vi·ªác ch√≠nh', 'C√¥ng vi·ªác kh√°c']:
                display_jobs.append(job)
        
        # N·∫øu kh√¥ng c√≥ job n√†o, d√πng t·∫•t c·∫£
        if not display_jobs:
            display_jobs = all_jobs
        
        # Ch·ªçn n∆°i l√†m vi·ªác b·∫±ng Radio Button
        if display_jobs:
            selected_job_id = st.radio(
                "üè† Ch·ªçn N∆°i L√†m Vi·ªác:",
                options=[j['id'] for j in display_jobs],
                format_func=lambda x: f"{job_map[x]['job_name']} ({job_map[x]['hourly_rate']:,.0f}ƒë/h)",
                horizontal=True,
                key="job_radio"
            )
        else:
            selected_job_id = None
            st.warning("Ch∆∞a c√≥ c√¥ng vi·ªác n√†o. H√£y th√™m c√¥ng vi·ªác b√™n d∆∞·ªõi!")
        
        # N√∫t th√™m c√¥ng vi·ªác m·ªõi
        with st.expander("üå∫ Th√™m c√¥ng vi·ªác m·ªõi"):
            new_name = st.text_input("T√™n c√¥ng vi·ªác:", key="new_job_name", placeholder="VD: Restaurant, Shop...")
            new_rate = st.number_input("L∆∞∆°ng gi·ªù (Yen):", min_value=0, value=1000, step=50, key="new_job_rate")
            
            if st.button("Th√™m C√¥ng Vi·ªác", key="btn_add_job", type="primary"):
                if new_name and new_name.strip():
                    result = db.add_job(new_name.strip(), new_rate, "")
                    if result > 0:
                        st.success(f"Da them: {new_name} - {new_rate} Yen/h")
                        st.rerun()
                    else:
                        st.error("Loi khi them cong viec!")
                else:
                    st.warning("Vui long nhap ten cong viec!")
        
        # T√™n ca
        shift_count = len(existing_shifts) + 1
        default_shift_names = ["Ca s√°ng", "Ca chi·ªÅu", "Ca t·ªëi", "Ca ƒë√™m"]
        default_name = default_shift_names[min(shift_count - 1, len(default_shift_names) - 1)] if shift_count <= 4 else f"Ca {shift_count}"
        
        shift_name = st.text_input(
            "üìõ T√™n ca:",
            value=default_name,
            placeholder="V√≠ d·ª•: Ca s√°ng, Ca t·ªëi, C√¥ng vi·ªác 2..."
        )
        
        # Gi·ªù b·∫Øt ƒë·∫ßu
        col_start, col_end = st.columns(2)
        
        with col_start:
            # ƒê·ªÅ xu·∫•t gi·ªù b·∫Øt ƒë·∫ßu d·ª±a tr√™n ca tr∆∞·ªõc
            if existing_shifts:
                last_end = existing_shifts[-1]['end_time']
                h, m = map(int, last_end.split(':'))
                default_start = time(h, m)
            else:
                default_start = time(8, 0)
            
            start_time = st.time_input(
                "üåü Gi·ªù b·∫Øt ƒë·∫ßu:",
                value=default_start,
                step=timedelta(minutes=15),
                key="new_shift_start"
            )
        
        with col_end:
            # ƒê·ªÅ xu·∫•t gi·ªù k·∫øt th√∫c
            default_end = time(17, 0) if not existing_shifts else time(0, 0)
            
            end_time = st.time_input(
                "üïî Gi·ªù k·∫øt th√∫c:",
                value=default_end,
                step=timedelta(minutes=15),
                key="new_shift_end",
                help="üí° H·ªó tr·ª£ ca qua ƒë√™m: v√≠ d·ª• 22:00 - 06:00"
            )
        
        # Gi·ªù ngh·ªâ
        break_hours = st.number_input(
            "‚òï Gi·ªù ngh·ªâ (gi·ªù):",
            min_value=0.0,
            max_value=4.0,
            value=0.0 if existing_shifts else db.get_default_break_hours(),
            step=0.25,
            help="ƒê·ªÉ 0 n·∫øu ca n√†y kh√¥ng c√≥ ngh·ªâ",
            key="new_shift_break"
        )
        
        # Ghi ch√∫
        notes = st.text_input(
            "‚úèÔ∏è Ghi ch√∫ (t√πy ch·ªçn):",
            placeholder="V√≠ d·ª•: C√¥ng vi·ªác A, d·ª± √°n XYZ...",
            key="new_shift_notes"
        )
    
    with col2:
        st.subheader("üëÄ Xem Tr∆∞·ªõc")
        
        # Chuy·ªÉn ƒë·ªïi time sang string
        start_str = start_time.strftime("%H:%M")
        end_str = end_time.strftime("%H:%M")
        
        # T√≠nh to√°n cho ca m·ªõi
        result = calc.calculate_full(start_str, end_str, break_hours, standard_hours)
        
        if result["success"]:
            # T√≠nh t·ªïng ng√†y n·∫øu th√™m ca n√†y
            new_total_day = (total_hours_day if existing_shifts else 0) + result['total_hours']
            new_ot_day = max(0, new_total_day - standard_hours)
            
            # Hi·ªÉn th·ªã preview
            is_overnight = end_time <= start_time
            time_display = f"{start_str} - {end_str}" + (" üåõ" if is_overnight else "")
            
            # T√≠nh l∆∞∆°ng ∆∞·ªõc t√≠nh
            job_rate = job_map.get(selected_job_id, {}).get('hourly_rate', 0) if selected_job_id else 0
            shift_salary = result['total_hours'] * job_rate
            
            st.markdown(f"""
            <div class="result-box">
                <h4>üåü Ca: {shift_name}</h4>
                <p><strong>üåü Th·ªùi gian:</strong> {time_display}</p>
                <p><strong>‚åõ Gi·ªù l√†m ca n√†y:</strong> <span class="text-success" style="font-size: 1.3rem;">{calc.format_hours(result['total_hours'])}</span></p>
                <p><strong>üíù L∆∞∆°ng ∆∞·ªõc t√≠nh:</strong> <span class="text-warning" style="font-size: 1.3rem;">{shift_salary:,.0f} Yen</span></p>
                <hr>
                <p><strong>üìÖ T·ªïng gi·ªù ng√†y (sau khi th√™m):</strong> <span style="font-size: 1.2rem;">{calc.format_hours(new_total_day)}</span></p>
            </div>
            """, unsafe_allow_html=True)
            
            # N√∫t th√™m ca
            if st.button("‚ú® Th√™m Ca L√†m Vi·ªác", type="primary", use_container_width=True):
                shift_id = db.add_work_shift(
                    work_date=work_date,
                    shift_name=shift_name,
                    start_time=start_str,
                    end_time=end_str,
                    break_hours=break_hours,
                    total_hours=result['total_hours'],
                    notes=notes,
                    job_id=selected_job_id
                )
                
                if shift_id > 0:
                    st.success(f"üéâ ƒê√£ th√™m {shift_name} th√†nh c√¥ng!")
                    st.balloons()
                    st.rerun()
                else:
                    st.error("üòø L·ªói khi th√™m ca. Vui l√≤ng th·ª≠ l·∫°i!")
        else:
            st.markdown(f"""
            <div class="error-box">
                <p>{result['error_message']}</p>
            </div>
            """, unsafe_allow_html=True)
    
    # X√≥a t·∫•t c·∫£ ca c·ªßa ng√†y
    if existing_shifts:
        st.markdown("---")
        
        # Hi·ªÉn th·ªã t·ªïng k·∫øt ng√†y v√† n√∫t ho√†n th√†nh
        st.subheader("üåà T·ªïng K·∫øt Ng√†y")
        
        col_summary1, col_summary2 = st.columns(2)
        
        with col_summary1:
            st.markdown(f"""
            <div class="result-box">
                <h4>üìÖ Ng√†y {work_date.strftime('%d/%m/%Y')}</h4>
                <p><strong>üéØ S·ªë ca:</strong> {len(existing_shifts)} ca</p>
                <p><strong>‚åõ T·ªïng gi·ªù l√†m:</strong> <span class="text-success">{calc.format_hours(total_hours_day)}</span></p>
                <p><strong>üíù T·ªïng l∆∞∆°ng:</strong> <span class="text-warning">{total_salary_day:,.0f} Yen</span></p>
            </div>
            """, unsafe_allow_html=True)
        
        with col_summary2:
            # Chi ti·∫øt c√°c ca v·ªõi l∆∞∆°ng
            shifts_info = "<br>".join([
                f"‚Ä¢ {s['shift_name']}: {s['total_hours']}h = {s['total_hours'] * job_map.get(s.get('job_id', 1), {}).get('hourly_rate', 0):,.0f} Yen"
                for s in existing_shifts
            ])
            st.markdown(f"""
            <div class="result-box" style="font-size: 0.9rem;">
                <h4>üìå Chi Ti·∫øt C√°c Ca</h4>
                {shifts_info}
            </div>
            """, unsafe_allow_html=True)
        
        # N√∫t Ho√†n th√†nh v√† X√≥a
        col_complete, col_delete = st.columns([2, 1])
        
        with col_complete:
            if st.button("üéä Ho√†n Th√†nh Nh·∫≠p Li·ªáu", type="primary", use_container_width=True):
                st.success(f"""
                üéä **ƒê√£ ho√†n th√†nh nh·∫≠p li·ªáu cho ng√†y {work_date.strftime('%d/%m/%Y')}!**
                
                - üìÖ S·ªë ca: **{len(existing_shifts)} ca**
                - ‚åõ T·ªïng gi·ªù: **{calc.format_hours(total_hours_day)}**
                - üíù T·ªïng l∆∞∆°ng: **{total_salary_day:,.0f} Yen**
                
                B·∫°n c√≥ th·ªÉ xem trong tab **üóìÔ∏è L·ªãch L√†m** ƒë·ªÉ ki·ªÉm tra.
                """)
                st.balloons()
        
        with col_delete:
            if st.button("üóëÔ∏è X√≥a T·∫•t C·∫£", use_container_width=True):
                if db.delete_work_log(work_date):
                    st.success("üóëÔ∏è ƒê√£ x√≥a t·∫•t c·∫£ ca!")
                    st.rerun()
                else:
                    st.error("üòø L·ªói khi x√≥a!")

# ==================== TAB 2: L·ªäCH L√ÄM ====================

with tab2:
    st.header("üóìÔ∏è L·ªãch L√†m Vi·ªác")
    
    # Ch·ªçn th√°ng/nƒÉm
    col_month, col_year, col_view = st.columns([1, 1, 1])
    
    with col_month:
        selected_month = st.selectbox(
            "Th√°ng:",
            options=list(range(1, 13)),
            index=date.today().month - 1,
            format_func=lambda x: f"Th√°ng {x}"
        )
    
    with col_year:
        current_year = date.today().year
        selected_year = st.selectbox(
            "NƒÉm:",
            options=list(range(current_year - 5, current_year + 2)),
            index=5  # Current year
        )
    
    with col_view:
        view_type = st.selectbox(
            "Ki·ªÉu xem:",
            options=["L·ªãch th√°ng", "Danh s√°ch"]
        )
    
    # L·∫•y d·ªØ li·ªáu th√°ng
    try:
        work_logs = db.get_work_logs_by_month(selected_year, selected_month)
    except Exception as e:
        # N·∫øu l·ªói (c√≥ th·ªÉ do ch∆∞a init table m·ªõi), th·ª≠ init l·∫°i
        # st.warning(f"ƒêang ƒë·ªìng b·ªô d·ªØ li·ªáu... ({e})")
        db.init_database()
        try:
            work_logs = db.get_work_logs_by_month(selected_year, selected_month)
        except Exception:
            work_logs = []
    holidays = db.get_holidays_by_year(selected_year)
    holiday_dates = [h['holiday_date'] for h in holidays]
    
    # T·∫°o dict ƒë·ªÉ tra c·ª©u nhanh
    log_dict = {log['work_date']: log for log in work_logs}
    
    if view_type == "L·ªãch th√°ng":
        # T·∫°o calendar view
        st.subheader(f"üìÖ L·ªãch Th√°ng {selected_month}/{selected_year}")
        
        # L·∫•y calendar c·ªßa th√°ng
        cal = calendar.Calendar(firstweekday=0)  # Monday = 0
        month_days = list(cal.itermonthdays2(selected_year, selected_month))
        
        # Header ng√†y trong tu·∫ßn
        weekdays = ["Th·ª© 2", "Th·ª© 3", "Th·ª© 4", "Th·ª© 5", "Th·ª© 6", "Th·ª© 7", "CN"]
        cols = st.columns(7)
        for i, day_name in enumerate(weekdays):
            with cols[i]:
                st.markdown(f"**{day_name}**")
        
        # Hi·ªÉn th·ªã c√°c tu·∫ßn
        week = []
        for day, weekday in month_days:
            week.append((day, weekday))
            if len(week) == 7:
                cols = st.columns(7)
                for i, (d, wd) in enumerate(week):
                    with cols[i]:
                        if d == 0:
                            st.write("")
                        else:
                            day_date = date(selected_year, selected_month, d)
                            day_str = day_date.isoformat()
                            
                            # X√°c ƒë·ªãnh tr·∫°ng th√°i ng√†y
                            if day_str in holiday_dates:
                                st.markdown(f"""
                                <div class="cal-cell holiday">
                                    <div class="cal-day-num">{d}</div>
                                    <div class="cal-day-info text-error">üå∏ Ngh·ªâ l·ªÖ</div>
                                </div>
                                """, unsafe_allow_html=True)
                            elif day_str in log_dict:
                                log = log_dict[day_str]
                                shift_count = log.get('shift_count', 1)
                                shift_label = f"({shift_count} ca)" if shift_count > 1 else ""
                                
                                st.markdown(f"""
                                <div class="cal-cell worked">
                                    <div class="cal-day-num">{d}</div>
                                    <div class="cal-day-info text-success">‚úø {log['total_hours']}h</div>
                                    <div class="cal-day-info" style="font-size:0.65rem;">{shift_label}</div>
                                </div>
                                """, unsafe_allow_html=True)
                            elif wd >= 5:  # Weekend
                                st.markdown(f"""
                                <div class="cal-cell weekend">
                                    <div class="cal-day-num text-muted">{d}</div>
                                    <div class="cal-day-info text-muted">Cu·ªëi tu·∫ßn</div>
                                </div>
                                """, unsafe_allow_html=True)
                            else:
                                st.markdown(f"""
                                <div class="cal-cell empty">
                                    <div class="cal-day-num">{d}</div>
                                    <div class="cal-day-info text-muted">-</div>
                                </div>
                                """, unsafe_allow_html=True)
                week = []
        
        # Ch√∫ th√≠ch
        st.markdown("---")
        st.markdown("""
        **Ch√∫ th√≠ch:**
        - üü¢ Xanh l√°: Ng√†y c√≥ l√†m vi·ªác
        - üî¥ ƒê·ªè: Ng√†y ngh·ªâ l·ªÖ
        - ‚¨ú Tr·∫Øng: Ch∆∞a c√≥ d·ªØ li·ªáu
        """)
        
        # T·ªïng k·∫øt th√°ng cho L·ªãch th√°ng
        if work_logs:
            st.markdown("---")
            st.subheader("üåà T·ªïng K·∫øt Th√°ng")
            
            total_days = len(work_logs)
            total_hours = sum(log['total_hours'] for log in work_logs)
            avg_hours = total_hours / total_days if total_days > 0 else 0
            
            # Hi·ªÉn th·ªã metrics (kh√¥ng c√≥ OT)
            col1, col2, col3 = st.columns(3)
            with col1:
                st.metric(
                    label="üìÖ Ng√†y L√†m Vi·ªác",
                    value=f"{total_days} ng√†y"
                )
            with col2:
                st.metric(
                    label="‚è±Ô∏è T·ªïng Gi·ªù L√†m",
                    value=calc.format_hours(total_hours)
                )
            with col3:
                st.metric(
                    label="üìä Trung B√¨nh/Ng√†y",
                    value=calc.format_hours(avg_hours)
                )
        else:
            st.info("‚ÑπÔ∏è Ch∆∞a c√≥ d·ªØ li·ªáu gi·ªù l√†m cho th√°ng n√†y.")
    
    else:  # Danh s√°ch
        st.subheader(f"üìã Danh S√°ch Gi·ªù L√†m Th√°ng {selected_month}/{selected_year}")
        
        if work_logs:
            # T·∫°o DataFrame
            df = pd.DataFrame(work_logs)
            
            # Format l·∫°i c√°c c·ªôt
            df['work_date'] = pd.to_datetime(df['work_date']).dt.strftime('%d/%m/%Y')
            df['total_hours'] = df['total_hours'].apply(lambda x: f"{x} gi·ªù")
            
            # ƒê·ªïi t√™n c·ªôt (b·ªè OT)
            df_display = df[['work_date', 'start_time', 'end_time', 'break_hours', 'total_hours', 'notes']].copy()
            df_display.columns = ['Ng√†y', 'Gi·ªù b·∫Øt ƒë·∫ßu', 'Gi·ªù k·∫øt th√∫c', 'Ngh·ªâ (h)', 'T·ªïng gi·ªù', 'Ghi ch√∫']
            
            st.dataframe(df_display, use_container_width=True, hide_index=True)
            
            # T·ªïng k·∫øt th√°ng (kh√¥ng OT)
            st.markdown("---")
            total_days = len(work_logs)
            total_hours = sum(log['total_hours'] for log in work_logs)
            
            col1, col2 = st.columns(2)
            with col1:
                st.metric("üìÖ S·ªë ng√†y l√†m vi·ªác", f"{total_days} ng√†y")
            with col2:
                st.metric("‚åõ T·ªïng gi·ªù l√†m", calc.format_hours(total_hours))
        else:
            st.info("‚ÑπÔ∏è Ch∆∞a c√≥ d·ªØ li·ªáu gi·ªù l√†m cho th√°ng n√†y.")
    
    # ==================== CH·ªàNH S·ª¨A CA L√ÄM VI·ªÜC ====================
    st.markdown("---")
    st.subheader("‚úèÔ∏è Ch·ªânh S·ª≠a Ca L√†m Vi·ªác")
    
    # Ch·ªçn ng√†y ƒë·ªÉ ch·ªânh s·ª≠a
    col_edit_date, col_edit_info = st.columns([1, 2])
    
    with col_edit_date:
        # T·∫°o ng√†y m·∫∑c ƒë·ªãnh trong th√°ng ƒëang xem
        default_edit_date = date(selected_year, selected_month, min(date.today().day, 28))
        edit_date = st.date_input(
            "üóìÔ∏è Ch·ªçn ng√†y ƒë·ªÉ xem/s·ª≠a:",
            value=default_edit_date,
            format="DD/MM/YYYY",
            key="calendar_edit_date"
        )
    
    with col_edit_info:
        # L·∫•y c√°c ca l√†m vi·ªác c·ªßa ng√†y ƒë√£ ch·ªçn
        edit_shifts = db.get_shifts_by_date(edit_date)
        
        if edit_shifts:
            total_h = sum(s['total_hours'] for s in edit_shifts)
            st.success(f"üåü Ng√†y {edit_date.strftime('%d/%m/%Y')}: {len(edit_shifts)} ca, {total_h:.1f} gi·ªù")
        else:
            st.info(f"üå∏ Ng√†y {edit_date.strftime('%d/%m/%Y')}: Ch∆∞a c√≥ ca l√†m vi·ªác")
    
    # Hi·ªÉn th·ªã v√† cho ph√©p ch·ªânh s·ª≠a c√°c ca
    if edit_shifts:
        all_jobs = db.get_all_jobs()
        job_options = {j['id']: f"{j['job_name']} ({j['hourly_rate']:,.0f} Yen/h)" for j in all_jobs}
        job_ids = list(job_options.keys())
        
        for i, shift in enumerate(edit_shifts):
            with st.expander(f"üåü {shift['shift_name']} ({shift['start_time']} - {shift['end_time']})", expanded=False):
                col_e1, col_e2, col_e3 = st.columns(3)
                
                with col_e1:
                    # Ch·ªânh s·ª≠a th·ªùi gian b·∫Øt ƒë·∫ßu
                    try:
                        start_parts = shift['start_time'].split(':')
                        default_start = time(int(start_parts[0]), int(start_parts[1]))
                    except:
                        default_start = time(9, 0)
                    
                    new_start = st.time_input(
                        "Gi·ªù b·∫Øt ƒë·∫ßu:",
                        value=default_start,
                        key=f"edit_start_{shift['id']}"
                    )
                
                with col_e2:
                    # Ch·ªânh s·ª≠a th·ªùi gian k·∫øt th√∫c
                    try:
                        end_parts = shift['end_time'].split(':')
                        default_end = time(int(end_parts[0]), int(end_parts[1]))
                    except:
                        default_end = time(17, 0)
                    
                    new_end = st.time_input(
                        "Gi·ªù k·∫øt th√∫c:",
                        value=default_end,
                        key=f"edit_end_{shift['id']}"
                    )
                
                with col_e3:
                    # Ch·ªânh s·ª≠a gi·ªù ngh·ªâ
                    new_break = st.number_input(
                        "Gi·ªù ngh·ªâ:",
                        min_value=0.0,
                        max_value=4.0,
                        value=float(shift['break_hours']),
                        step=0.25,
                        key=f"edit_break_{shift['id']}"
                    )
                
                col_e4, col_e5 = st.columns(2)
                
                with col_e4:
                    # Ch·ªânh s·ª≠a c√¥ng vi·ªác
                    current_job_id = shift.get('job_id', 1)
                    if current_job_id in job_ids:
                        default_idx = job_ids.index(current_job_id)
                    else:
                        default_idx = 0
                    
                    new_job = st.selectbox(
                        "N∆°i l√†m vi·ªác:",
                        options=job_ids,
                        index=default_idx,
                        format_func=lambda x: job_options.get(x, "N/A"),
                        key=f"edit_job_{shift['id']}"
                    )
                
                with col_e5:
                    # Ch·ªânh s·ª≠a t√™n ca
                    new_shift_name = st.text_input(
                        "T√™n ca:",
                        value=shift['shift_name'],
                        key=f"edit_name_{shift['id']}"
                    )
                
                # Ghi ch√∫
                new_notes = st.text_input(
                    "Ghi ch√∫:",
                    value=shift.get('notes', ''),
                    key=f"edit_notes_{shift['id']}"
                )
                
                # T√≠nh gi·ªù l√†m m·ªõi
                start_dt = datetime.combine(edit_date, new_start)
                end_dt = datetime.combine(edit_date, new_end)
                if new_end <= new_start:  # Ca ƒë√™m
                    end_dt += timedelta(days=1)
                new_total_hours = (end_dt - start_dt).total_seconds() / 3600 - new_break
                new_total_hours = max(0, new_total_hours)
                
                st.write(f"‚åõ **Gi·ªù l√†m m·ªõi:** {new_total_hours:.1f} gi·ªù")
                
                # N√∫t L∆∞u v√† X√≥a
                col_save, col_del = st.columns(2)
                
                with col_save:
                    if st.button("üíñ L∆∞u Thay ƒê·ªïi", key=f"save_shift_{shift['id']}", type="primary"):
                        success = db.update_work_shift(
                            shift_id=shift['id'],
                            shift_name=new_shift_name,
                            start_time=new_start.strftime('%H:%M'),
                            end_time=new_end.strftime('%H:%M'),
                            break_hours=new_break,
                            total_hours=new_total_hours,
                            notes=new_notes
                        )
                        if success:
                            st.success("üéâ ƒê√£ c·∫≠p nh·∫≠t ca l√†m vi·ªác!")
                            st.rerun()
                        else:
                            st.error("üòø L·ªói khi c·∫≠p nh·∫≠t!")
                
                with col_del:
                    if st.button("üóëÔ∏è X√≥a Ca N√†y", key=f"delete_shift_{shift['id']}"):
                        if db.delete_work_shift(shift['id']):
                            st.success("üóëÔ∏è ƒê√£ x√≥a ca!")
                            st.rerun()
                        else:
                            st.error("üòø L·ªói khi x√≥a!")
    
    # N√∫t th√™m ca m·ªõi cho ng√†y ƒë√£ ch·ªçn
    st.markdown("---")
    with st.expander(f"‚ú® Th√™m ca m·ªõi cho ng√†y {edit_date.strftime('%d/%m/%Y')}"):
        all_jobs = db.get_all_jobs()
        job_map = {j['id']: j for j in all_jobs}
        
        col_add1, col_add2, col_add3 = st.columns(3)
        
        with col_add1:
            add_start = st.time_input("Gi·ªù b·∫Øt ƒë·∫ßu:", value=time(9, 0), key="add_shift_start")
        with col_add2:
            add_end = st.time_input("Gi·ªù k·∫øt th√∫c:", value=time(17, 0), key="add_shift_end")
        with col_add3:
            add_break = st.number_input("Gi·ªù ngh·ªâ:", min_value=0.0, max_value=4.0, value=1.0, step=0.25, key="add_shift_break")
        
        col_add4, col_add5 = st.columns(2)
        
        with col_add4:
            add_job = st.selectbox(
                "N∆°i l√†m vi·ªác:",
                options=[j['id'] for j in all_jobs],
                format_func=lambda x: f"{job_map[x]['job_name']} ({job_map[x]['hourly_rate']:,.0f} Yen/h)",
                key="add_shift_job"
            )
        with col_add5:
            add_name = st.text_input("T√™n ca:", value="Ca l√†m", key="add_shift_name")
        
        add_notes = st.text_input("Ghi ch√∫:", key="add_shift_notes")
        
        # T√≠nh gi·ªù l√†m
        add_start_dt = datetime.combine(edit_date, add_start)
        add_end_dt = datetime.combine(edit_date, add_end)
        if add_end <= add_start:
            add_end_dt += timedelta(days=1)
        add_total = max(0, (add_end_dt - add_start_dt).total_seconds() / 3600 - add_break)
        
        st.write(f"‚åõ **Gi·ªù l√†m:** {add_total:.1f} gi·ªù | üíù **L∆∞∆°ng ∆∞·ªõc t√≠nh:** {add_total * job_map.get(add_job, {}).get('hourly_rate', 0):,.0f} Yen")
        
        if st.button("‚ú® Th√™m Ca", type="primary", key="add_new_shift_calendar"):
            shift_id = db.add_work_shift(
                work_date=edit_date,
                shift_name=add_name,
                start_time=add_start.strftime('%H:%M'),
                end_time=add_end.strftime('%H:%M'),
                break_hours=add_break,
                total_hours=add_total,
                notes=add_notes,
                job_id=add_job
            )
            if shift_id > 0:
                st.success(f"üéâ ƒê√£ th√™m ca l√†m vi·ªác cho ng√†y {edit_date.strftime('%d/%m/%Y')}!")
                st.rerun()
            else:
                st.error("üòø L·ªói khi th√™m ca!")

# ==================== TAB 3: B√ÅO C√ÅO ====================

with tab3:
    st.header("‚ú® B√°o C√°o Gi·ªù L√†m")
    
    # Ch·ªçn kho·∫£ng th·ªùi gian
    st.subheader("üìÖ Ch·ªçn Kho·∫£ng Th·ªùi Gian")
    
    col1, col2 = st.columns(2)
    
    with col1:
        # M·∫∑c ƒë·ªãnh: ƒë·∫ßu th√°ng hi·ªán t·∫°i
        default_start = date.today().replace(day=1)
        report_start = st.date_input(
            "T·ª´ ng√†y:",
            value=default_start,
            format="DD/MM/YYYY"
        )
    
    with col2:
        report_end = st.date_input(
            "ƒê·∫øn ng√†y:",
            value=date.today(),
            format="DD/MM/YYYY"
        )
    
    if report_start > report_end:
        st.error("‚ùå Ng√†y b·∫Øt ƒë·∫ßu ph·∫£i tr∆∞·ªõc ng√†y k·∫øt th√∫c!")
    else:
        # L·∫•y d·ªØ li·ªáu
        report_logs = db.get_work_logs_by_range(report_start, report_end)
        standard_hours = db.get_standard_hours()
        
        if report_logs:
            # T·∫°o b√°o c√°o
            report = calc.generate_report(report_logs, standard_hours)
            
            # Hi·ªÉn th·ªã th·ªëng k√™ (kh√¥ng c√≥ OT)
            st.subheader("‚ú® Th·ªëng K√™ T·ªïng Quan")
            
            col1, col2, col3 = st.columns(3)
            
            with col1:
                st.metric(
                    "üìÖ S·ªë Ng√†y L√†m",
                    f"{report['total_days']} ng√†y"
                )
            
            with col2:
                st.metric(
                    "‚è±Ô∏è T·ªïng Gi·ªù L√†m",
                    calc.format_hours(report['total_hours'])
                )
            
            with col3:
                st.metric(
                    "üìä Trung B√¨nh/Ng√†y",
                    calc.format_hours(report['average_hours'])
                )
            
            st.markdown("---")
            
            # ==================== T√çNH L∆Ø∆†NG D·ª∞ T√çNH ====================
            st.subheader("üí∞ L∆∞∆°ng D·ª± T√≠nh")
            
            # L·∫•y t·∫•t c·∫£ ca l√†m vi·ªác trong kho·∫£ng th·ªùi gian
            all_shifts = db.get_shifts_by_range(report_start, report_end)
            all_jobs = db.get_all_jobs()
            job_map = {j['id']: j for j in all_jobs}
            
            # T√≠nh l∆∞∆°ng theo t·ª´ng c√¥ng vi·ªác
            job_salary_data = {}
            total_salary = 0
            
            for shift in all_shifts:
                job_id = shift.get('job_id', 0)
                hours = shift.get('total_hours', 0)
                
                if job_id in job_map:
                    job_info = job_map[job_id]
                    job_name = job_info['job_name']
                    hourly_rate = job_info['hourly_rate']
                else:
                    job_name = "Ch∆∞a ph√¢n lo·∫°i"
                    hourly_rate = 0
                
                if job_name not in job_salary_data:
                    job_salary_data[job_name] = {
                        'hours': 0,
                        'salary': 0,
                        'hourly_rate': hourly_rate,
                        'shift_count': 0
                    }
                
                job_salary_data[job_name]['hours'] += hours
                job_salary_data[job_name]['salary'] += hours * hourly_rate
                job_salary_data[job_name]['shift_count'] += 1
                total_salary += hours * hourly_rate
            
            # Hi·ªÉn th·ªã t·ªïng l∆∞∆°ng
            col_salary1, col_salary2 = st.columns([1, 2])
            
            with col_salary1:
                st.markdown(f"""
                <div class="stat-card" style="background: linear-gradient(135deg, #F59E0B 0%, #D97706 100%);">
                    <h3>üí¥ {total_salary:,.0f}</h3>
                    <p>Yen (L∆∞∆°ng d·ª± t√≠nh)</p>
                </div>
                """, unsafe_allow_html=True)
            
            with col_salary2:
                # Hi·ªÉn th·ªã chi ti·∫øt theo t·ª´ng c√¥ng vi·ªác
                if job_salary_data:
                    st.markdown("**üìã Chi ti·∫øt theo c√¥ng vi·ªác:**")
                    for job_name, data in job_salary_data.items():
                        if data['salary'] > 0:
                            st.markdown(f"""
                            - **{job_name}**: {data['hours']:.1f}h √ó {data['hourly_rate']:,.0f} Yen = **{data['salary']:,.0f} Yen** ({data['shift_count']} ca)
                            """)
            
            st.markdown("---")
            
            # Bi·ªÉu ƒë·ªì gi·ªù l√†m
            st.subheader("üìà Bi·ªÉu ƒê·ªì Gi·ªù L√†m")
            
            df = pd.DataFrame(report_logs)
            df['work_date'] = pd.to_datetime(df['work_date'])
            
            # Bi·ªÉu ƒë·ªì c·ªôt ƒë∆°n gi·∫£n (ch·ªâ t·ªïng gi·ªù, kh√¥ng ph√¢n chia OT)
            fig = go.Figure()
            
            fig.add_trace(go.Bar(
                x=df['work_date'],
                y=df['total_hours'],
                name='Gi·ªù l√†m',
                marker_color='#22C55E'
            ))
            
            fig.update_layout(
                title='Gi·ªù L√†m Theo Ng√†y',
                xaxis_title='Ng√†y',
                yaxis_title='S·ªë Gi·ªù',
                height=400
            )
            
            st.plotly_chart(fig, use_container_width=True)
            
            st.markdown("---")
            
            # Xu·∫•t Excel
            st.subheader("üì§ Xu·∫•t B√°o C√°o")
            
            # L·∫•y t·∫•t c·∫£ shifts ƒë·ªÉ t√≠nh l∆∞∆°ng
            export_shifts = db.get_shifts_by_range(report_start, report_end)
            all_jobs_export = db.get_all_jobs()
            job_map_export = {j['id']: j for j in all_jobs_export}
            
            # Chu·∫©n b·ªã d·ªØ li·ªáu xu·∫•t v·ªõi c·ªôt l∆∞∆°ng
            export_data = []
            total_salary_export = 0
            
            for shift in export_shifts:
                job_id = shift.get('job_id', 1)
                job_info = job_map_export.get(job_id, {'job_name': 'N/A', 'hourly_rate': 0})
                salary = shift['total_hours'] * job_info['hourly_rate']
                total_salary_export += salary
                
                export_data.append({
                    'Ng√†y': shift['work_date'],
                    'Ca l√†m': shift['shift_name'],
                    'N∆°i l√†m': job_info['job_name'],
                    'Gi·ªù Bƒê': shift['start_time'],
                    'Gi·ªù KT': shift['end_time'],
                    'Ngh·ªâ (h)': shift['break_hours'],
                    'T·ªïng gi·ªù': shift['total_hours'],
                    'L∆∞∆°ng/h': job_info['hourly_rate'],
                    'L∆∞∆°ng ca': salary,
                    'Ghi ch√∫': shift.get('notes', '')
                })
            
            if export_data:
                df_export = pd.DataFrame(export_data)
                
                # Th√™m d√≤ng t·ªïng k·∫øt
                summary_row = {
                    'Ng√†y': 'T·ªîNG C·ªòNG',
                    'Ca l√†m': '',
                    'N∆°i l√†m': '',
                    'Gi·ªù Bƒê': '',
                    'Gi·ªù KT': '',
                    'Ngh·ªâ (h)': '',
                    'T·ªïng gi·ªù': sum(s['total_hours'] for s in export_shifts),
                    'L∆∞∆°ng/h': '',
                    'L∆∞∆°ng ca': total_salary_export,
                    'Ghi ch√∫': ''
                }
                df_export = pd.concat([df_export, pd.DataFrame([summary_row])], ignore_index=True)
                
                # T·∫°o file Excel
                output = BytesIO()
                with pd.ExcelWriter(output, engine='openpyxl') as writer:
                    df_export.to_excel(writer, sheet_name='Bao Cao Gio Lam', index=False)
                
                excel_data = output.getvalue()
                
                col_export1, col_export2 = st.columns(2)
                
                with col_export1:
                    st.download_button(
                        label="üíæ T·∫£i Excel",
                        data=excel_data,
                        file_name=f"bao_cao_{report_start.strftime('%d%m%Y')}_{report_end.strftime('%d%m%Y')}.xlsx",
                        mime="application/vnd.openxmlformats-officedocument.spreadsheetml.sheet",
                        use_container_width=True
                    )
                
                with col_export2:
                    # Export CSV
                    csv_data = df_export.to_csv(index=False).encode('utf-8-sig')
                    st.download_button(
                        label="üìÑ T·∫£i CSV",
                        data=csv_data,
                        file_name=f"bao_cao_{report_start.strftime('%d%m%Y')}_{report_end.strftime('%d%m%Y')}.csv",
                        mime="text/csv",
                        use_container_width=True
                    )
                
                st.success(f"üìä T·ªïng l∆∞∆°ng trong k·ª≥: **{total_salary_export:,.0f} Yen**")
            
            # ==================== T√çNH L∆Ø∆†NG ====================
            st.markdown("---")
            st.subheader("üíù T√≠nh L∆∞∆°ng Theo Gi·ªù")
            
            # L·∫•y t·∫•t c·∫£ shifts trong kho·∫£ng th·ªùi gian b√°o c√°o
            shifts_data = db.get_shifts_by_range(report_start, report_end)
            
            if shifts_data:
                # L·∫•y danh s√°ch c√¥ng vi·ªác
                all_jobs = db.get_all_jobs()
                job_map = {j['id']: j for j in all_jobs}
                
                # T√≠nh l∆∞∆°ng theo t·ª´ng c√¥ng vi·ªác
                job_salary = {}
                total_hours_all = 0
                total_salary_all = 0
                
                for shift in shifts_data:
                    job_id = shift.get('job_id') or 1
                    job_info = job_map.get(job_id, {'job_name': 'Chua phan loai', 'hourly_rate': 0})
                    job_name = job_info.get('job_name', 'Chua phan loai')
                    hourly_rate = job_info.get('hourly_rate', 0)
                    hours = shift['total_hours']
                    
                    if job_id not in job_salary:
                        job_salary[job_id] = {
                            'job_id': job_id,
                            'job_name': job_name,
                            'hourly_rate': hourly_rate,
                            'total_hours': 0,
                            'shift_count': 0,
                            'base_salary': 0
                        }
                    
                    job_salary[job_id]['total_hours'] += hours
                    job_salary[job_id]['shift_count'] += 1
                    job_salary[job_id]['base_salary'] += hours * hourly_rate
                    total_hours_all += hours
                    total_salary_all += hours * hourly_rate
                
                # Hi·ªÉn th·ªã t·ªïng quan l∆∞∆°ng
                col_sal1, col_sal2, col_sal3 = st.columns(3)
                
                with col_sal1:
                    st.metric(
                        "üíù T·ªïng L∆∞∆°ng",
                        f"{total_salary_all:,.0f} Yen"
                    )
                
                with col_sal2:
                    st.metric(
                        "‚åõ T·ªïng Gi·ªù",
                        f"{total_hours_all:.1f} gi·ªù"
                    )
                
                with col_sal3:
                    avg_rate = total_salary_all / total_hours_all if total_hours_all > 0 else 0
                    st.metric(
                        "‚ú® TB L∆∞∆°ng/Gi·ªù",
                        f"{avg_rate:,.0f} Yen/h"
                    )
                
                # Chi ti·∫øt theo c√¥ng vi·ªác
                if job_salary:
                    st.markdown("---")
                    st.markdown("**üìå Chi Ti·∫øt L∆∞∆°ng Theo C√¥ng Vi·ªác:**")
                    
                    for job_id, job in job_salary.items():
                        with st.expander(f"üè† {job['job_name']} - {job['total_hours']:.1f}h = {job['base_salary']:,.0f} Yen"):
                            col_j1, col_j2, col_j3 = st.columns(3)
                            with col_j1:
                                st.write(f"**L∆∞∆°ng gi·ªù:** {job['hourly_rate']:,.0f} Yen/h")
                            with col_j2:
                                st.write(f"**S·ªë ca:** {job['shift_count']} ca")
                            with col_j3:
                                st.write(f"**T·ªïng gi·ªù:** {job['total_hours']:.1f} gi·ªù")
                            
                            st.markdown(f"**T·ªïng l∆∞∆°ng:** `{job['base_salary']:,.0f} Yen` = {job['total_hours']:.1f}h √ó {job['hourly_rate']:,.0f} Yen/h")
                    
                    # Bi·ªÉu ƒë·ªì ph√¢n b·ªï l∆∞∆°ng theo c√¥ng vi·ªác
                    if len(job_salary) > 1:
                        fig_salary = px.pie(
                            values=[j['base_salary'] for j in job_salary.values()],
                            names=[j['job_name'] for j in job_salary.values()],
                            title='Phan Bo Luong Theo Cong Viec',
                            color_discrete_sequence=px.colors.qualitative.Pastel
                        )
                        st.plotly_chart(fig_salary, use_container_width=True)
                
                # B·∫£ng t·ªïng h·ª£p l∆∞∆°ng
                st.markdown("---")
                st.markdown(f"""
                <div class="result-box" style="text-align: center;">
                    <h3>üíù TONG LUONG ({report_start.strftime('%d/%m')} - {report_end.strftime('%d/%m/%Y')})</h3>
                    <table style="width: 100%; margin-top: 1rem;">
                        <tr style="border-bottom: 2px solid #667eea;">
                            <td style="text-align: left; padding: 0.5rem; font-size: 1.2rem;"><strong>TONG CONG ({total_hours_all:.1f} gio)</strong></td>
                            <td style="text-align: right; padding: 0.5rem; font-size: 1.5rem; color: #22C55E;"><strong>{total_salary_all:,.0f} Yen</strong></td>
                        </tr>
                    </table>
                </div>
                """, unsafe_allow_html=True)
            else:
                st.info("üå∏ Chua co du lieu de tinh luong. Hay nhap gio lam truoc!")
                
        else:
            st.info("‚ÑπÔ∏è Kh√¥ng c√≥ d·ªØ li·ªáu trong kho·∫£ng th·ªùi gian n√†y.")

# ==================== TAB 4: T√ôY CH·ªàNH ====================

with tab4:
    st.header("üéÄ C√†i ƒê·∫∑t C√†i ƒê·∫∑t")
    
    # C√†i ƒë·∫∑t gi·ªù l√†m
    st.subheader("üåü C√†i ƒê·∫∑t Gi·ªù L√†m")
    
    col1, col2 = st.columns(2)
    
    with col1:
        current_standard = db.get_standard_hours()
        new_standard = st.number_input(
            "Gi·ªù l√†m chu·∫©n (gi·ªù/ng√†y):",
            min_value=1.0,
            max_value=12.0,
            value=current_standard,
            step=0.5,
            help="S·ªë gi·ªù l√†m vi·ªác ti√™u chu·∫©n m·ªói ng√†y. Gi·ªù l√†m v∆∞·ª£t qu√° s·∫Ω t√≠nh l√† gi·ªù l√†m th√™m."
        )
        
        if st.button("üíñ L∆∞u Gi·ªù Chu·∫©n", key="save_standard"):
            if db.update_setting("standard_hours", str(new_standard)):
                st.success(f"üí´ ƒê√£ c·∫≠p nh·∫≠t gi·ªù l√†m chu·∫©n: {new_standard} gi·ªù")
            else:
                st.error("üòø L·ªói khi l∆∞u!")
    
    with col2:
        current_break = db.get_default_break_hours()
        new_break = st.number_input(
            "Gi·ªù ngh·ªâ m·∫∑c ƒë·ªãnh (gi·ªù):",
            min_value=0.0,
            max_value=3.0,
            value=current_break,
            step=0.25,
            help="Th·ªùi gian ngh·ªâ tr∆∞a v√† ngh·ªâ gi·∫£i lao m·∫∑c ƒë·ªãnh."
        )
        
        if st.button("üíñ L∆∞u Gi·ªù Ngh·ªâ", key="save_break"):
            if db.update_setting("break_hours", str(new_break)):
                st.success(f"üí´ ƒê√£ c·∫≠p nh·∫≠t gi·ªù ngh·ªâ m·∫∑c ƒë·ªãnh: {new_break} gi·ªù")
            else:
                st.error("üòø L·ªói khi l∆∞u!")
    
    st.markdown("---")
    
    # ==================== QU·∫¢N L√ù C√îNG VI·ªÜC ====================
    st.subheader("üè† Qu·∫£n L√Ω C√¥ng Vi·ªác & L∆∞∆°ng Gi·ªù")
    
    col_job1, col_job2 = st.columns([1, 2])
    
    with col_job1:
        st.markdown("**üå∫ Th√™m C√¥ng Vi·ªác M·ªõi**")
        
        settings_job_name = st.text_input(
            "T√™n c√¥ng vi·ªác:",
            placeholder="V√≠ d·ª•: C√¥ng vi·ªác A, Part-time B...",
            key="settings_new_job_name"
        )
        
        settings_hourly_rate = st.number_input(
            "L∆∞∆°ng gi·ªù (VNƒê):",
            min_value=0,
            max_value=1000000,
            value=50000,
            step=5000,
            key="settings_hourly_rate",
            help="S·ªë ti·ªÅn l∆∞∆°ng cho m·ªói gi·ªù l√†m vi·ªác"
        )
        
        settings_job_desc = st.text_input(
            "M√¥ t·∫£ (t√πy ch·ªçn):",
            placeholder="M√¥ t·∫£ ng·∫Øn v·ªÅ c√¥ng vi·ªác",
            key="settings_job_desc"
        )
        
        if st.button("üå∫ Th√™m C√¥ng Vi·ªác", type="primary", key="settings_add_job"):
            if settings_job_name:
                job_id = db.add_job(settings_job_name, settings_hourly_rate, settings_job_desc)
                if job_id > 0:
                    st.success(f"Da them cong viec: {settings_job_name}")
                    st.rerun()
                else:
                    st.error("Loi khi them!")
            else:
                st.warning("Vui long nhap ten cong viec!")
    
    with col_job2:
        st.markdown("**üìã Danh S√°ch C√¥ng Vi·ªác**")
        
        jobs = db.get_all_jobs()
        
        if jobs:
            for job in jobs:
                with st.expander(f"üè† {job['job_name']} - {job['hourly_rate']:,.0f} Yen/h"):
                    col_edit1, col_edit2 = st.columns([2, 1])
                    
                    with col_edit1:
                        # Ch·ªânh s·ª≠a t√™n c√¥ng vi·ªác
                        updated_name = st.text_input(
                            "T√™n c√¥ng vi·ªác:",
                            value=job['job_name'],
                            key=f"name_{job['id']}"
                        )
                        
                        # Ch·ªânh s·ª≠a l∆∞∆°ng gi·ªù
                        updated_rate = st.number_input(
                            f"L∆∞∆°ng gi·ªù (Yen/h):",
                            min_value=0,
                            max_value=1000000,
                            value=int(job['hourly_rate']),
                            step=100,
                            key=f"rate_{job['id']}"
                        )
                        
                        # Ch·ªânh s·ª≠a m√¥ t·∫£
                        updated_desc = st.text_input(
                            "M√¥ t·∫£:",
                            value=job.get('description', ''),
                            key=f"desc_{job['id']}"
                        )
                        
                        if st.button("üíñ C·∫≠p Nh·∫≠t C√¥ng Vi·ªác", key=f"update_job_{job['id']}", type="primary"):
                            if db.update_job(job['id'], updated_name, updated_rate, updated_desc):
                                st.success("üéâ ƒê√£ c·∫≠p nh·∫≠t c√¥ng vi·ªác!")
                                st.rerun()
                            else:
                                st.error("üòø L·ªói khi c·∫≠p nh·∫≠t!")
                    
                    with col_edit2:
                        st.write(f"**ID:** {job['id']}")
                        if job.get('description'):
                            st.write(f"**M√¥ t·∫£:** {job['description']}")
                        
                        st.markdown("---")
                        st.markdown("**üóëÔ∏è X√≥a C√¥ng Vi·ªác**")
                        
                        # Ki·ªÉm tra xem c√¥ng vi·ªác c√≥ ƒëang ƒë∆∞·ª£c s·ª≠ d·ª•ng kh√¥ng
                        # L·∫•y s·ªë ca ƒëang d√πng c√¥ng vi·ªác n√†y
                        shifts_using = db.get_connection()
                        cursor = shifts_using.cursor()
                        cursor.execute("SELECT COUNT(*) FROM work_shifts WHERE job_id = ?", (job['id'],))
                        count = cursor.fetchone()[0]
                        shifts_using.close()
                        
                        if count > 0:
                            st.warning(f"‚ö†Ô∏è C√≥ {count} ca ƒëang d√πng c√¥ng vi·ªác n√†y")
                            
                            # Checkbox x√°c nh·∫≠n x√≥a
                            confirm_delete = st.checkbox(
                                f"T√¥i x√°c nh·∫≠n mu·ªën x√≥a",
                                key=f"confirm_del_{job['id']}"
                            )
                            
                            if confirm_delete:
                                if st.button("üóëÔ∏è X√≥a C√¥ng Vi·ªác", key=f"del_job_{job['id']}", type="secondary"):
                                    if db.delete_job(job['id']):
                                        st.success("üóëÔ∏è ƒê√£ x√≥a c√¥ng vi·ªác!")
                                        st.rerun()
                                    else:
                                        st.error("üòø L·ªói khi x√≥a!")
                        else:
                            st.info("‚úÖ C√¥ng vi·ªác n√†y ch∆∞a ƒë∆∞·ª£c s·ª≠ d·ª•ng")
                            if st.button("üóëÔ∏è X√≥a C√¥ng Vi·ªác", key=f"del_job_{job['id']}", type="secondary"):
                                if db.delete_job(job['id']):
                                    st.success("üóëÔ∏è ƒê√£ x√≥a c√¥ng vi·ªác!")
                                    st.rerun()
                                else:
                                    st.error("üòø L·ªói khi x√≥a!")
        else:
            st.info("üå∏ Ch∆∞a c√≥ c√¥ng vi·ªác n√†o. H√£y th√™m c√¥ng vi·ªác m·ªõi!")
    
    st.markdown("---")
    
    # Qu·∫£n l√Ω ng√†y ngh·ªâ
    st.subheader("üå∏ Qu·∫£n L√Ω Ng√†y Ngh·ªâ L·ªÖ")
    
    col1, col2 = st.columns([1, 2])
    
    with col1:
        st.markdown("**‚ûï Th√™m Ng√†y Ngh·ªâ M·ªõi**")
        
        new_holiday_date = st.date_input(
            "Ch·ªçn ng√†y:",
            value=date.today(),
            format="DD/MM/YYYY",
            key="new_holiday"
        )
        
        new_holiday_desc = st.text_input(
            "M√¥ t·∫£:",
            placeholder="V√≠ d·ª•: T·∫øt Nguy√™n ƒê√°n, 30/4, ..."
        )
        
        if st.button("‚ûï Th√™m Ng√†y Ngh·ªâ", type="primary"):
            if new_holiday_desc.strip():
                if db.add_holiday(new_holiday_date, new_holiday_desc.strip()):
                    st.success(f"üéâ ƒê√£ th√™m ng√†y ngh·ªâ: {new_holiday_date.strftime('%d/%m/%Y')} - {new_holiday_desc}")
                    st.rerun()
                else:
                    st.error("üòø L·ªói khi th√™m ng√†y ngh·ªâ!")
            else:
                st.warning("‚ö†Ô∏è Vui l√≤ng nh·∫≠p m√¥ t·∫£ cho ng√†y ngh·ªâ!")
    
    with col2:
        st.markdown("**üìã Danh S√°ch Ng√†y Ngh·ªâ**")
        
        holidays = db.get_all_holidays()
        
        if holidays:
            for holiday in holidays:
                hol_date = datetime.strptime(holiday['holiday_date'], '%Y-%m-%d').strftime('%d/%m/%Y')
                col_info, col_delete = st.columns([4, 1])
                
                with col_info:
                    st.write(f"üéå **{hol_date}** - {holiday['description']}")
                
                with col_delete:
                    if st.button("üóëÔ∏è", key=f"del_{holiday['id']}", help="X√≥a ng√†y ngh·ªâ n√†y"):
                        hol_date_obj = datetime.strptime(holiday['holiday_date'], '%Y-%m-%d').date()
                        if db.remove_holiday(hol_date_obj):
                            st.success("ƒê√£ x√≥a!")
                            st.rerun()
        else:
            st.info("‚ÑπÔ∏è Ch∆∞a c√≥ ng√†y ngh·ªâ n√†o ƒë∆∞·ª£c th√™m.")
        
        st.markdown("---")
        
        # Th√™m nhanh ng√†y l·ªÖ Vi·ªát Nam
        st.markdown("**üáªüá≥ Th√™m Nhanh Ng√†y L·ªÖ Vi·ªát Nam**")
        
        current_year = date.today().year
        vn_holidays = [
            (date(current_year, 1, 1), "T·∫øt D∆∞∆°ng L·ªãch"),
            (date(current_year, 4, 30), "Ng√†y Gi·∫£i Ph√≥ng Mi·ªÅn Nam"),
            (date(current_year, 5, 1), "Ng√†y Qu·ªëc T·∫ø Lao ƒê·ªông"),
            (date(current_year, 9, 2), "Ng√†y Qu·ªëc Kh√°nh"),
        ]
        
        if st.button("üáªüá≥ Th√™m C√°c Ng√†y L·ªÖ Ch√≠nh NƒÉm " + str(current_year)):
            added = 0
            for hol_date, hol_desc in vn_holidays:
                if db.add_holiday(hol_date, hol_desc):
                    added += 1
            st.success(f"üéâ ƒê√£ th√™m {added} ng√†y l·ªÖ!")
            st.rerun()

# ==================== SIDEBAR ====================

with st.sidebar:
    st.markdown("### ‚ú® Th·ªëng K√™ Nhanh")
    
    # Th·ªëng k√™ th√°ng hi·ªán t·∫°i
    today = date.today()
    current_month_logs = db.get_work_logs_by_month(today.year, today.month)
    
    if current_month_logs:
        total_hours = sum(log['total_hours'] for log in current_month_logs)
        
        st.metric("Th√°ng n√†y", f"{len(current_month_logs)} ng√†y")
        st.metric("T·ªïng gi·ªù l√†m", calc.format_hours(total_hours))
    else:
        st.info("Ch∆∞a c√≥ d·ªØ li·ªáu th√°ng n√†y")
    
    st.markdown("---")
    
    st.markdown("### üíå Th√¥ng Tin")
    st.markdown("""
    **Qu·∫£n L√Ω Gi·ªù L√†m** v1.0
    
    ·ª®ng d·ª•ng gi√∫p b·∫°n:
    - üìù Ghi nh·∫≠n gi·ªù l√†m h√†ng ng√†y
    - üè† Qu·∫£n l√Ω nhi·ªÅu c√¥ng vi·ªác
    - üí∞ T√≠nh l∆∞∆°ng theo gi·ªù
    - üìÖ Xem l·ªãch l√†m vi·ªác
    - üìä T·∫°o b√°o c√°o chi ti·∫øt
    """)
    
    st.markdown("---")
    
    # Version info
    st.caption("¬© 2024 - Ph√°t tri·ªÉn b·ªüi AI")



==================================================
FILE: user_auth.py
==================================================
# -*- coding: utf-8 -*-
"""
Module x√°c th·ª±c ng∆∞·ªùi d√πng cho ·ª©ng d·ª•ng Qu·∫£n L√Ω Gi·ªù L√†m.
H·ªó tr·ª£ c·∫£ Supabase (cloud) v√† SQLite (local fallback).
"""

import streamlit as st
import hashlib
import os
import sqlite3
import sqlite3
try:
    import extra_streamlit_components as stx
    _COOKIE_MANAGER_OK = True
except ImportError:
    stx = None
    _COOKIE_MANAGER_OK = False
from datetime import datetime, timedelta
from typing import Optional, Dict

# Th·ª≠ import Supabase module
try:
    import supabase_db
    _SUPABASE_MODULE_OK = True
except:
    _SUPABASE_MODULE_OK = False

def _check_supabase() -> bool:
    """Ki·ªÉm tra Supabase c√≥ s·∫µn kh√¥ng (g·ªçi m·ªói l·∫ßn, kh√¥ng cache)."""
    if not _SUPABASE_MODULE_OK:
        return False
    try:
        return supabase_db.is_supabase_available()
    except:
        return False

# ƒê∆∞·ªùng d·∫´n th∆∞ m·ª•c ch·ª©a database c·ªßa users (for SQLite fallback)
DATA_DIR = os.path.join(os.path.dirname(os.path.abspath(__file__)), "user_data")

# ƒê·∫£m b·∫£o th∆∞ m·ª•c t·ªìn t·∫°i
if not os.path.exists(DATA_DIR):
    os.makedirs(DATA_DIR)


def get_users_db_path() -> str:
    """L·∫•y ƒë∆∞·ªùng d·∫´n database ch·ª©a th√¥ng tin users."""
    return os.path.join(DATA_DIR, "users.db")


def get_user_db_path(username: str) -> str:
    """L·∫•y ƒë∆∞·ªùng d·∫´n database ri√™ng c·ªßa user."""
    safe_username = "".join(c for c in username.lower() if c.isalnum() or c == "_")
    return os.path.join(DATA_DIR, f"user_{safe_username}.db")


def init_users_db() -> None:
    """Kh·ªüi t·∫°o database users (SQLite)."""
    conn = sqlite3.connect(get_users_db_path())
    cursor = conn.cursor()
    
    cursor.execute("""
        CREATE TABLE IF NOT EXISTS users (
            id INTEGER PRIMARY KEY AUTOINCREMENT,
            username TEXT NOT NULL UNIQUE,
            password_hash TEXT NOT NULL,
            display_name TEXT,
            created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
            last_login TIMESTAMP
        )
    """)
    
    conn.commit()
    conn.close()


def hash_password(password: str) -> str:
    """M√£ h√≥a m·∫≠t kh·∫©u."""
    return hashlib.sha256(password.encode()).hexdigest()


def is_using_supabase() -> bool:
    """Ki·ªÉm tra c√≥ ƒëang d√πng Supabase kh√¥ng."""
    return _check_supabase()


def register_user(username: str, password: str, display_name: str = "") -> tuple:
    """
    ƒêƒÉng k√Ω ng∆∞·ªùi d√πng m·ªõi.
    
    Returns:
        (success, message)
    """
    # Validate input
    if len(username) < 3:
        return False, "T√™n ƒëƒÉng nh·∫≠p ph·∫£i c√≥ √≠t nh·∫•t 3 k√Ω t·ª±"
    
    if len(password) < 4:
        return False, "M·∫≠t kh·∫©u ph·∫£i c√≥ √≠t nh·∫•t 4 k√Ω t·ª±"
    
    if not username.replace("_", "").isalnum():
        return False, "T√™n ƒëƒÉng nh·∫≠p ch·ªâ ƒë∆∞·ª£c ch·ª©a ch·ªØ c√°i, s·ªë v√† g·∫°ch d∆∞·ªõi"
    
    password_hash = hash_password(password)
    display = display_name if display_name else username
    
    # Th·ª≠ Supabase tr∆∞·ªõc
    if _check_supabase():
        try:
            # Check if user exists
            existing = supabase_db.get_user_by_username(username)
            if existing:
                return False, "T√™n ƒëƒÉng nh·∫≠p ƒë√£ t·ªìn t·∫°i"
            
            # Create user
            user = supabase_db.create_user(username, password_hash, display)
            if user:
                # Init default data
                supabase_db.init_user_default_data(user['id'])
                return True, "ƒêƒÉng k√Ω th√†nh c√¥ng! B·∫°n c√≥ th·ªÉ ƒëƒÉng nh·∫≠p ngay."
            else:
                return False, "L·ªói khi t·∫°o t√†i kho·∫£n"
        except Exception as e:
            return False, f"L·ªói: {str(e)}"
    
    # Fallback to SQLite
    try:
        init_users_db()
        
        conn = sqlite3.connect(get_users_db_path())
        cursor = conn.cursor()
        
        cursor.execute("SELECT id FROM users WHERE username = ?", (username.lower(),))
        if cursor.fetchone():
            conn.close()
            return False, "T√™n ƒëƒÉng nh·∫≠p ƒë√£ t·ªìn t·∫°i"
        
        cursor.execute("""
            INSERT INTO users (username, password_hash, display_name)
            VALUES (?, ?, ?)
        """, (username.lower(), password_hash, display))
        
        conn.commit()
        conn.close()
        
        return True, "ƒêƒÉng k√Ω th√†nh c√¥ng! B·∫°n c√≥ th·ªÉ ƒëƒÉng nh·∫≠p ngay."
    
    except Exception as e:
        return False, f"L·ªói: {str(e)}"


def login_user(username: str, password: str) -> tuple:
    """
    ƒêƒÉng nh·∫≠p ng∆∞·ªùi d√πng.
    
    Returns:
        (success, message, user_info)
    """
    password_hash = hash_password(password)
    
    # Th·ª≠ Supabase tr∆∞·ªõc
    if _check_supabase():
        try:
            user = supabase_db.get_user_by_username(username)
            if user and user['password_hash'] == password_hash:
                supabase_db.update_user_last_login(user['id'])
                return True, "ƒêƒÉng nh·∫≠p th√†nh c√¥ng!", user
            else:
                return False, "T√™n ƒëƒÉng nh·∫≠p ho·∫∑c m·∫≠t kh·∫©u kh√¥ng ƒë√∫ng", None
        except Exception as e:
            return False, f"L·ªói: {str(e)}", None
    
    # Fallback to SQLite
    try:
        init_users_db()
        
        conn = sqlite3.connect(get_users_db_path())
        conn.row_factory = sqlite3.Row
        cursor = conn.cursor()
        
        cursor.execute("""
            SELECT * FROM users WHERE username = ? AND password_hash = ?
        """, (username.lower(), password_hash))
        
        row = cursor.fetchone()
        
        if row:
            cursor.execute("""
                UPDATE users SET last_login = CURRENT_TIMESTAMP
                WHERE id = ?
            """, (row['id'],))
            conn.commit()
            
            user_info = dict(row)
            conn.close()
            
            return True, "ƒêƒÉng nh·∫≠p th√†nh c√¥ng!", user_info
        else:
            conn.close()
            return False, "T√™n ƒëƒÉng nh·∫≠p ho·∫∑c m·∫≠t kh·∫©u kh√¥ng ƒë√∫ng", None
    
    except Exception as e:
        return False, f"L·ªói: {str(e)}", None


def is_logged_in() -> bool:
    """Ki·ªÉm tra ng∆∞·ªùi d√πng ƒë√£ ƒëƒÉng nh·∫≠p ch∆∞a."""
    return st.session_state.get("logged_in", False) and st.session_state.get("user_info") is not None


def get_current_user() -> Optional[Dict]:
    """L·∫•y th√¥ng tin ng∆∞·ªùi d√πng hi·ªán t·∫°i."""
    if is_logged_in():
        return st.session_state.get("user_info")
    return None


def get_current_user_id() -> Optional[int]:
    """L·∫•y user_id c·ªßa ng∆∞·ªùi d√πng hi·ªán t·∫°i."""
    user = get_current_user()
    if user:
        return user.get('id')
    return None


@st.cache_resource
def get_cookie_manager():
    if not _COOKIE_MANAGER_OK or stx is None:
        return None
    try:
        return stx.CookieManager(key="auth_cookie_manager")
    except:
        return None


def set_remember_me_cookie(username: str, password_hash: str):
    """L∆∞u cookie ƒëƒÉng nh·∫≠p (30 ng√†y)."""
    if not _COOKIE_MANAGER_OK:
        return
        
    try:
        cookie_manager = get_cookie_manager()
        if cookie_manager:
            # Token format: username|password_hash
            token = f"{username}|{password_hash}"
            expires = datetime.now() + timedelta(days=30)
            cookie_manager.set("work_tracker_token", token, expires_at=expires)
    except:
        pass


def check_auto_login() -> bool:
    """Ki·ªÉm tra cookie ƒë·ªÉ login t·ª± ƒë·ªông."""
    if is_logged_in():
        return True

    if not _COOKIE_MANAGER_OK:
        return False

    try:
        cookie_manager = get_cookie_manager()
        if not cookie_manager:
            return False
            
        cookies = cookie_manager.get_all()
        token = cookies.get("work_tracker_token")
        
        if token and "|" in token:
            username, pw_hash = token.split("|", 1)
            
            # Verify with DB
            if _check_supabase():
               user = supabase_db.get_user_by_username(username)
               if user and user['password_hash'] == pw_hash:
                   st.session_state["logged_in"] = True
                   st.session_state["user_info"] = user
                   st.session_state["user_db_path"] = None
                   supabase_db.update_user_last_login(user['id'])
                   return True
            else:
                # Local SQLite verification
                init_users_db()
                conn = sqlite3.connect(get_users_db_path())
                conn.row_factory = sqlite3.Row
                cursor = conn.cursor()
                cursor.execute("SELECT * FROM users WHERE username = ? AND password_hash = ?", (username, pw_hash))
                row = cursor.fetchone()
                conn.close()
                
                if row:
                    st.session_state["logged_in"] = True
                    st.session_state["user_info"] = dict(row)
                    st.session_state["user_db_path"] = get_user_db_path(username)
                    
                    # Update last login
                    conn = sqlite3.connect(get_users_db_path())
                    conn.execute("UPDATE users SET last_login = CURRENT_TIMESTAMP WHERE id = ?", (row['id'],))
                    conn.commit()
                    conn.close()
                    return True
    except Exception as e:
        print(f"Auto login error: {e}")
        
    return False


def logout():
    """ƒêƒÉng xu·∫•t ng∆∞·ªùi d√πng."""
    st.session_state["logged_in"] = False
    st.session_state["user_info"] = None
    st.session_state["user_db_path"] = None
    
    # X√≥a Cookie
    if _COOKIE_MANAGER_OK:
        try:
            cookie_manager = get_cookie_manager()
            if cookie_manager:
                cookie_manager.delete("work_tracker_token")
        except:
            pass


def show_login_page():
    """Hi·ªÉn th·ªã trang ƒëƒÉng nh·∫≠p/ƒëƒÉng k√Ω."""
    
    st.markdown("""
    <style>
        .auth-container {
            max-width: 400px;
            margin: 0 auto;
            padding: 2rem;
        }
        .auth-header {
            text-align: center;
            margin-bottom: 2rem;
        }
        .auth-header h1 {
            font-size: 3rem;
            background: linear-gradient(to right, #00C6FB, #005BEA);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            font-weight: 800;
            letter-spacing: 2px;
            text-transform: uppercase;
        }
        .db-status {
            text-align: center;
            padding: 0.5rem;
            border-radius: 8px;
            margin-bottom: 1rem;
        }
    </style>
    """, unsafe_allow_html=True)
    
    st.markdown('<div class="auth-header"><h1>üöÄ Qu·∫£n L√Ω Gi·ªù L√†m</h1></div>', unsafe_allow_html=True)
    
    # Hi·ªÉn th·ªã tr·∫°ng th√°i database
    is_cloud = _check_supabase()
    if is_cloud:
        st.success("‚òÅÔ∏è **Cloud Mode** - D·ªØ li·ªáu ƒë∆∞·ª£c l∆∞u tr√™n Supabase")
    else:
        st.warning("üíæ **Local Mode** - D·ªØ li·ªáu l∆∞u c·ª•c b·ªô (c√≥ th·ªÉ m·∫•t khi reboot)")
    
    # Debug info - LU√îN HI·ªÇN TH·ªä
    with st.expander("üîß Debug Info - Ki·ªÉm tra k·∫øt n·ªëi", expanded=not is_cloud):
        import os
        st.write("**Ki·ªÉm tra Streamlit Secrets:**")
        has_secrets = hasattr(st, 'secrets')
        st.write(f"- hasattr(st, 'secrets'): `{has_secrets}`")
        
        if has_secrets:
            try:
                secrets_keys = list(st.secrets.keys()) if hasattr(st.secrets, 'keys') else "N/A"
                st.write(f"- Secrets keys: `{secrets_keys}`")
            except Exception as e:
                st.write(f"- Secrets keys: Error - `{e}`")
            
            try:
                has_url = "SUPABASE_URL" in st.secrets
                has_key = "SUPABASE_KEY" in st.secrets
                st.write(f"- SUPABASE_URL in secrets: `{has_url}`")
                st.write(f"- SUPABASE_KEY in secrets: `{has_key}`")
                
                if has_url:
                    url_val = st.secrets["SUPABASE_URL"]
                    st.write(f"- SUPABASE_URL value: `{url_val[:30]}...`")
            except Exception as e:
                st.write(f"- Error checking secrets: `{e}`")
        
        st.write("**Ki·ªÉm tra Environment Variables:**")
        env_url = os.environ.get("SUPABASE_URL", "")
        env_key = os.environ.get("SUPABASE_KEY", "")
        st.write(f"- ENV SUPABASE_URL: `{'Set (' + env_url[:20] + '...)' if env_url else 'Not set'}`")
        st.write(f"- ENV SUPABASE_KEY: `{'Set' if env_key else 'Not set'}`")
        
        st.write("**K·∫øt qu·∫£ ki·ªÉm tra Supabase:**")
        st.write(f"- _check_supabase(): `{is_cloud}`")
        st.write(f"- _SUPABASE_MODULE_OK: `{_SUPABASE_MODULE_OK}`")
        
        # Show last error if available
        if not is_cloud:
            if _SUPABASE_MODULE_OK:
                try:
                    last_err = supabase_db.get_last_error()
                    st.error(f"**L·ªói Supabase:** `{last_err}`")
                except Exception as ex:
                    st.error(f"**L·ªói khi l·∫•y error:** `{ex}`")
            else:
                st.error("**L·ªói:** Kh√¥ng th·ªÉ import supabase_db module")
    
    # Tabs ƒëƒÉng nh·∫≠p / ƒëƒÉng k√Ω
    tab_login, tab_register = st.tabs(["üë§ ƒêƒÉng Nh·∫≠p", "‚ú® ƒêƒÉng K√Ω"])
    
    with tab_login:
        st.subheader("Ch√†o m·ª´ng tr·ªü l·∫°i üëã")
        
        with st.form("login_form"):
            username = st.text_input("T√™n ƒëƒÉng nh·∫≠p", placeholder="Nh·∫≠p t√™n ƒëƒÉng nh·∫≠p")
            password = st.text_input("M·∫≠t kh·∫©u", type="password", placeholder="Nh·∫≠p m·∫≠t kh·∫©u")
            
            remember_me = False
            if _COOKIE_MANAGER_OK:
                remember_me = st.checkbox("Ghi nh·ªõ ƒëƒÉng nh·∫≠p (30 ng√†y)")
            
            submit = st.form_submit_button("ƒêƒÉng Nh·∫≠p", use_container_width=True, type="primary")
            
            if submit:
                if username and password:
                    success, message, user_info = login_user(username, password)
                    
                    if success:
                        st.session_state["logged_in"] = True
                        st.session_state["user_info"] = user_info
                        st.session_state["user_db_path"] = get_user_db_path(username)
                        
                        if remember_me:
                            set_remember_me_cookie(username, user_info['password_hash'])
                            st.toast("ƒê√£ ghi nh·ªõ ƒëƒÉng nh·∫≠p!")
                        
                        st.success(message)
                        st.rerun()
                    else:
                        st.error(message)
                else:
                    st.warning("Vui l√≤ng nh·∫≠p ƒë·∫ßy ƒë·ªß th√¥ng tin")
    
    with tab_register:
        st.subheader("T·∫°o t√†i kho·∫£n m·ªõi üéâ")
        
        with st.form("register_form"):
            new_username = st.text_input("T√™n ƒëƒÉng nh·∫≠p", placeholder="√çt nh·∫•t 3 k√Ω t·ª±", key="reg_username")
            new_display = st.text_input("T√™n hi·ªÉn th·ªã (t√πy ch·ªçn)", placeholder="T√™n b·∫°n mu·ªën hi·ªÉn th·ªã", key="reg_display")
            new_password = st.text_input("M·∫≠t kh·∫©u", type="password", placeholder="√çt nh·∫•t 4 k√Ω t·ª±", key="reg_password")
            new_password2 = st.text_input("X√°c nh·∫≠n m·∫≠t kh·∫©u", type="password", placeholder="Nh·∫≠p l·∫°i m·∫≠t kh·∫©u", key="reg_password2")
            
            register = st.form_submit_button("ƒêƒÉng K√Ω", use_container_width=True, type="primary")
            
            if register:
                if new_password != new_password2:
                    st.error("M·∫≠t kh·∫©u kh√¥ng kh·ªõp!")
                elif new_username and new_password:
                    success, message = register_user(new_username, new_password, new_display)
                    if success:
                        st.success(message)
                        st.info("H√£y chuy·ªÉn sang tab ƒêƒÉng Nh·∫≠p")
                    else:
                        st.error(message)
                else:
                    st.warning("Vui l√≤ng nh·∫≠p ƒë·∫ßy ƒë·ªß th√¥ng tin")


def show_user_info_sidebar():
    """Hi·ªÉn th·ªã th√¥ng tin user ·ªü sidebar."""
    user = get_current_user()
    if user:
        with st.sidebar:
            st.markdown("---")
            st.markdown(f"### üëã Xin ch√†o,\n**{user.get('display_name') or user.get('username')}**")
            
            # Hi·ªÉn th·ªã mode database
            if is_using_supabase():
                st.caption("‚òÅÔ∏è Cloud Mode")
            else:
                st.caption("üíæ Local Mode")
                
            st.markdown("---")
            
            if st.button("üö™ ƒêƒÉng xu·∫•t", key="sidebar_logout", use_container_width=True):
                logout()
                st.rerun()


==================================================
FILE: db_wrapper.py
==================================================
Ôªø# -*- coding: utf-8 -*-
"""
Database Wrapper - T√°¬ª¬± √Ñ‚Äò√°¬ª‚Ñ¢ng ch√°¬ª¬çn Supabase ho√°¬∫¬∑c SQLite.
Import module n√É¬†y thay v√É¬¨ import tr√°¬ª¬±c ti√°¬∫¬øp database.py ho√°¬∫¬∑c supabase_db.py
"""

import streamlit as st
from datetime import date
from typing import List, Dict, Optional

# Th√°¬ª¬≠ import Supabase
try:
    import supabase_db
    _SUPABASE_MODULE_OK = True
except:
    _SUPABASE_MODULE_OK = False

# Import SQLite fallback
import database as sqlite_db


def _check_supabase() -> bool:
    """Ki√°¬ª∆ím tra Supabase c√É¬≥ s√°¬∫¬µn kh√É¬¥ng (g√°¬ª¬çi m√°¬ª‚Äîi l√°¬∫¬ßn)."""
    if not _SUPABASE_MODULE_OK:
        return False
    try:
        return supabase_db.is_supabase_available()
    except:
        return False


def is_cloud_mode() -> bool:
    """Ki√°¬ª∆ím tra √Ñ‚Äòang d√É¬πng cloud (Supabase) hay local (SQLite)."""
    return _check_supabase()


def _get_user_id() -> Optional[int]:
    """L√°¬∫¬•y user_id t√°¬ª¬´ session."""
    if "user_info" in st.session_state and st.session_state["user_info"]:
        return st.session_state["user_info"].get("id")
    return None


# ==================== JOBS ====================

def get_all_jobs() -> List[Dict]:
    """L√°¬∫¬•y t√°¬∫¬•t c√°¬∫¬£ c√É¬¥ng vi√°¬ª‚Ä°c."""
    if _check_supabase():
        user_id = _get_user_id()
        if user_id:
            return supabase_db.get_all_jobs(user_id)
        return []
    return sqlite_db.get_all_jobs()


def add_job(job_name: str, hourly_rate: float, description: str = "", color: str = "#667eea") -> Optional[int]:
    """Th√É¬™m c√É¬¥ng vi√°¬ª‚Ä°c m√°¬ª‚Ä∫i."""
    if _check_supabase():
        user_id = _get_user_id()
        if user_id:
            return supabase_db.add_job(user_id, job_name, hourly_rate, description, color)
        return None
    return sqlite_db.add_job(job_name, hourly_rate, description, color)


def update_job(job_id: int, job_name: str, hourly_rate: float, description: str = "", color: str = "#667eea") -> bool:
    """C√°¬∫¬≠p nh√°¬∫¬≠t c√É¬¥ng vi√°¬ª‚Ä°c."""
    if _check_supabase():
        return supabase_db.update_job(job_id, job_name, hourly_rate, description, color)
    return sqlite_db.update_job(job_id, job_name, hourly_rate, description, color)


def delete_job(job_id: int) -> bool:
    """X√É¬≥a c√É¬¥ng vi√°¬ª‚Ä°c."""
    if _check_supabase():
        return supabase_db.delete_job(job_id)
    return sqlite_db.delete_job(job_id)


def get_job_by_id(job_id: int) -> Optional[Dict]:
    """L√°¬∫¬•y th√É¬¥ng tin c√É¬¥ng vi√°¬ª‚Ä°c theo ID."""
    if _check_supabase():
        jobs = get_all_jobs()
        for job in jobs:
            if job['id'] == job_id:
                return job
        return None
    return sqlite_db.get_job_by_id(job_id)


# ==================== WORK SHIFTS ====================

def add_work_shift(
    work_date: date,
    shift_name: str,
    start_time: str,
    end_time: str,
    break_hours: float,
    total_hours: float,
    notes: str = "",
    job_id: int = None
) -> int:
    """Th√É¬™m ca l√É¬†m vi√°¬ª‚Ä°c m√°¬ª‚Ä∫i."""
    if _check_supabase():
        user_id = _get_user_id()
        if user_id:
            result = supabase_db.add_work_shift(user_id, work_date, shift_name, start_time, end_time, break_hours, total_hours, notes, job_id)
            return result if result else -1
        return -1
    return sqlite_db.add_work_shift(work_date, shift_name, start_time, end_time, break_hours, total_hours, notes, job_id)


def update_work_shift(
    shift_id: int,
    shift_name: str,
    start_time: str,
    end_time: str,
    break_hours: float,
    total_hours: float,
    notes: str = ""
) -> bool:
    """C√°¬∫¬≠p nh√°¬∫¬≠t ca l√É¬†m vi√°¬ª‚Ä°c."""
    if _check_supabase():
        return supabase_db.update_work_shift(shift_id, shift_name, start_time, end_time, break_hours, total_hours, notes)
    return sqlite_db.update_work_shift(shift_id, shift_name, start_time, end_time, break_hours, total_hours, notes)


def delete_work_shift(shift_id: int) -> bool:
    """X√É¬≥a ca l√É¬†m vi√°¬ª‚Ä°c."""
    if _check_supabase():
        return supabase_db.delete_work_shift(shift_id)
    return sqlite_db.delete_work_shift(shift_id)


def get_shifts_by_date(work_date: date) -> List[Dict]:
    """L√°¬∫¬•y c√É¬°c ca l√É¬†m vi√°¬ª‚Ä°c theo ng√É¬†y."""
    if _check_supabase():
        user_id = _get_user_id()
        if user_id:
            return supabase_db.get_shifts_by_date(user_id, work_date)
        return []
    return sqlite_db.get_shifts_by_date(work_date)


def get_shifts_by_range(start_date: date, end_date: date) -> List[Dict]:
    """L√°¬∫¬•y c√É¬°c ca l√É¬†m vi√°¬ª‚Ä°c trong kho√°¬∫¬£ng th√°¬ª¬ùi gian."""
    if _check_supabase():
        user_id = _get_user_id()
        if user_id:
            return supabase_db.get_shifts_by_range(user_id, start_date, end_date)
        return []
    return sqlite_db.get_shifts_by_range(start_date, end_date)


def get_shift_by_id(shift_id: int) -> Optional[Dict]:
    """L√°¬∫¬•y th√É¬¥ng tin ca l√É¬†m vi√°¬ª‚Ä°c theo ID."""
    return sqlite_db.get_shift_by_id(shift_id)


def get_daily_summary(work_date: date, standard_hours: float = 8.0) -> Dict:
    """L√°¬∫¬•y t√°¬ª‚Ä¢ng h√°¬ª¬£p gi√°¬ª¬ù l√É¬†m c√°¬ª¬ßa m√°¬ª‚Ñ¢t ng√É¬†y."""
    return sqlite_db.get_daily_summary(work_date, standard_hours)


def get_daily_summaries_by_range(start_date: date, end_date: date, standard_hours: float = 8.0) -> List[Dict]:
    """L√°¬∫¬•y t√°¬ª‚Ä¢ng h√°¬ª¬£p gi√°¬ª¬ù l√É¬†m theo ng√É¬†y trong kho√°¬∫¬£ng th√°¬ª¬ùi gian."""
    return sqlite_db.get_daily_summaries_by_range(start_date, end_date, standard_hours)


def get_daily_summaries_by_month(year: int, month: int, standard_hours: float = 8.0) -> List[Dict]:
    """L√°¬∫¬•y t√°¬ª‚Ä¢ng h√°¬ª¬£p gi√°¬ª¬ù l√É¬†m theo ng√É¬†y trong m√°¬ª‚Ñ¢t th√É¬°ng."""
    return sqlite_db.get_daily_summaries_by_month(year, month, standard_hours)


# ==================== HOLIDAYS ====================

def add_holiday(holiday_date: date, description: str) -> bool:
    """Th√É¬™m ng√É¬†y ngh√°¬ª‚Ä∞."""
    if _check_supabase():
        user_id = _get_user_id()
        if user_id:
            return supabase_db.add_holiday(user_id, holiday_date, description)
        return False
    return sqlite_db.add_holiday(holiday_date, description)


def remove_holiday(holiday_date: date) -> bool:
    """X√É¬≥a ng√É¬†y ngh√°¬ª‚Ä∞."""
    if _check_supabase():
        user_id = _get_user_id()
        if user_id:
            return supabase_db.remove_holiday(user_id, holiday_date)
        return False
    return sqlite_db.remove_holiday(holiday_date)


def get_all_holidays() -> List[Dict]:
    """L√°¬∫¬•y t√°¬∫¬•t c√°¬∫¬£ ng√É¬†y ngh√°¬ª‚Ä∞."""
    if _check_supabase():
        user_id = _get_user_id()
        if user_id:
            return supabase_db.get_all_holidays(user_id)
        return []
    return sqlite_db.get_all_holidays()


def get_holidays_by_year(year: int) -> List[Dict]:
    """L·∫•y danh s√°ch ng√†y ngh·ªâ trong nƒÉm."""
    if _check_supabase():
        # L·∫•y t·∫•t c·∫£ v√† l·ªçc (t·∫°m th·ªùi)
        all_holidays = get_all_holidays()
        return [h for h in all_holidays if str(h.get('holiday_date', '')).startswith(str(year))]
    return sqlite_db.get_holidays_by_year(year)


def is_holiday(check_date: date) -> tuple:
    """Ki√°¬ª∆ím tra ng√É¬†y ngh√°¬ª‚Ä∞."""
    if _check_supabase():
        user_id = _get_user_id()
        if user_id:
            return supabase_db.is_holiday(user_id, check_date)
        return False, ""
    return sqlite_db.is_holiday(check_date)


# ==================== SETTINGS ====================

def get_setting(key: str) -> Optional[str]:
    """L√°¬∫¬•y c√É¬†i √Ñ‚Äò√°¬∫¬∑t."""
    if _check_supabase():
        user_id = _get_user_id()
        if user_id:
            return supabase_db.get_setting(user_id, key)
        return None
    return sqlite_db.get_setting(key)


def update_setting(key: str, value: str) -> bool:
    """C√°¬∫¬≠p nh√°¬∫¬≠t c√É¬†i √Ñ‚Äò√°¬∫¬∑t."""
    if _check_supabase():
        user_id = _get_user_id()
        if user_id:
            return supabase_db.update_setting(user_id, key, value)
        return False
    return sqlite_db.update_setting(key, value)


def get_standard_hours() -> float:
    """L√°¬∫¬•y s√°¬ª‚Äò gi√°¬ª¬ù chu√°¬∫¬©n."""
    if _check_supabase():
        user_id = _get_user_id()
        if user_id:
            return supabase_db.get_standard_hours(user_id)
        return 8.0
    return sqlite_db.get_standard_hours()


def get_default_break_hours() -> float:
    """L√°¬∫¬•y gi√°¬ª¬ù ngh√°¬ª‚Ä∞ m√°¬∫¬∑c √Ñ‚Äò√°¬ª‚Äπnh."""
    if _check_supabase():
        user_id = _get_user_id()
        if user_id:
            return supabase_db.get_default_break_hours(user_id)
        return 1.0
    return sqlite_db.get_default_break_hours()


def get_ot_rate() -> float:
    """L√°¬∫¬•y h√°¬ª‚Ä° s√°¬ª‚Äò OT."""
    if _check_supabase():
        user_id = _get_user_id()
        if user_id:
            value = supabase_db.get_setting(user_id, 'ot_rate')
            return float(value) if value else 1.25
        return 1.25
    return sqlite_db.get_ot_rate()


# ==================== DATABASE INIT ====================

def init_database():
    """Kh√°¬ª≈∏i t√°¬∫¬°o database."""
    # Supabase kh√É¬¥ng c√°¬∫¬ßn init (√Ñ‚Äò√É¬£ c√É¬≥ tables s√°¬∫¬µn)
    if not _check_supabase():
        sqlite_db.init_database()


def clear_cache():
    """X√É¬≥a cache."""
    sqlite_db.clear_cache()


# ==================== COMPATIBILITY ====================

def get_work_logs_by_month(year: int, month: int) -> List[Dict]:
    """Compatibility wrapper for get_work_logs_by_month."""
    if _check_supabase():
        # Map to daily summaries
        return get_daily_summaries_by_month(year, month)
    return sqlite_db.get_work_logs_by_month(year, month)


def get_work_logs_by_range(start_date: date, end_date: date) -> List[Dict]:
    """Compatibility wrapper for get_work_logs_by_range."""
    if _check_supabase():
        return get_daily_summaries_by_range(start_date, end_date)
    return sqlite_db.get_work_logs_by_range(start_date, end_date)


def delete_work_log(work_date: date) -> bool:
    """Delete all work logs/shifts for a date."""
    if _check_supabase():
        # Delete all shifts for this date
        shifts = get_shifts_by_date(work_date)
        if not shifts:
            return True # Nothing to delete
            
        success = True
        for shift in shifts:
            if not delete_work_shift(shift['id']):
                success = False
        return success
    return sqlite_db.delete_work_log(work_date)


==================================================
FILE: database.py
==================================================
# -*- coding: utf-8 -*-
"""
Module qu·∫£n l√Ω c∆° s·ªü d·ªØ li·ªáu SQLite cho ·ª©ng d·ª•ng Qu·∫£n L√Ω Gi·ªù L√†m.
L∆∞u tr·ªØ gi·ªù l√†m (h·ªó tr·ª£ nhi·ªÅu ca/ng√†y), ng√†y ngh·ªâ, v√† c√†i ƒë·∫∑t ng∆∞·ªùi d√πng.
"""

import sqlite3
from datetime import datetime, date
from typing import List, Dict, Optional, Tuple
import os
import sys

# Thi·∫øt l·∫≠p UTF-8 encoding cho Windows
os.environ['PYTHONIOENCODING'] = 'utf-8'
try:
    if sys.stdout and sys.stdout.encoding != 'utf-8':
        sys.stdout.reconfigure(encoding='utf-8')
    if sys.stderr and sys.stderr.encoding != 'utf-8':
        sys.stderr.reconfigure(encoding='utf-8')
except:
    pass

# ƒê∆∞·ªùng d·∫´n database m·∫∑c ƒë·ªãnh (s·∫Ω ƒë∆∞·ª£c ghi ƒë√® b·ªüi user-specific path)
DEFAULT_DB_PATH = os.path.join(os.path.dirname(os.path.abspath(__file__)), "work_hours.db")

def get_db_path() -> str:
    """L·∫•y ƒë∆∞·ªùng d·∫´n database. ∆Øu ti√™n database c·ªßa user n·∫øu ƒë√£ ƒëƒÉng nh·∫≠p."""
    try:
        import streamlit as st
        if "user_db_path" in st.session_state and st.session_state["user_db_path"]:
            return st.session_state["user_db_path"]
    except:
        pass
    return DEFAULT_DB_PATH

# Alias cho t∆∞∆°ng th√≠ch
DB_PATH = DEFAULT_DB_PATH

# Cache ƒë∆°n gi·∫£n ƒë·ªÉ t·ªëi ∆∞u ƒë·ªçc database
_cache = {}
_cache_timeout = 5  # gi√¢y


def _get_cache(key):
    """L·∫•y d·ªØ li·ªáu t·ª´ cache n·∫øu c√≤n hi·ªáu l·ª±c."""
    if key in _cache:
        data, timestamp = _cache[key]
        if (datetime.now() - timestamp).seconds < _cache_timeout:
            return data
    return None


def _set_cache(key, data):
    """L∆∞u d·ªØ li·ªáu v√†o cache."""
    _cache[key] = (data, datetime.now())


def clear_cache():
    """X√≥a to√†n b·ªô cache."""
    global _cache
    _cache = {}


def get_connection() -> sqlite3.Connection:
    """T·∫°o k·∫øt n·ªëi ƒë·∫øn database."""
    db_path = get_db_path()
    # ƒê·∫£m b·∫£o th∆∞ m·ª•c t·ªìn t·∫°i
    db_dir = os.path.dirname(db_path)
    if db_dir and not os.path.exists(db_dir):
        os.makedirs(db_dir)
    conn = sqlite3.connect(db_path)
    conn.row_factory = sqlite3.Row  # Cho ph√©p truy c·∫≠p c·ªôt theo t√™n
    return conn


def init_database() -> None:
    """Kh·ªüi t·∫°o database v√† t·∫°o c√°c b·∫£ng n·∫øu ch∆∞a t·ªìn t·∫°i."""
    conn = get_connection()
    cursor = conn.cursor()
    
    # B·∫£ng l∆∞u gi·ªù l√†m h√†ng ng√†y (gi·ªØ l·∫°i ƒë·ªÉ t∆∞∆°ng th√≠ch ng∆∞·ª£c)
    cursor.execute("""
        CREATE TABLE IF NOT EXISTS work_logs (
            id INTEGER PRIMARY KEY AUTOINCREMENT,
            work_date DATE NOT NULL UNIQUE,
            start_time TEXT NOT NULL,
            end_time TEXT NOT NULL,
            break_hours REAL DEFAULT 1.0,
            total_hours REAL NOT NULL,
            overtime_hours REAL DEFAULT 0.0,
            notes TEXT,
            created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
            updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
        )
    """)
    
    # B·∫£ng l∆∞u c√¥ng vi·ªác v√† l∆∞∆°ng gi·ªù
    cursor.execute("""
        CREATE TABLE IF NOT EXISTS jobs (
            id INTEGER PRIMARY KEY AUTOINCREMENT,
            job_name TEXT NOT NULL UNIQUE,
            hourly_rate REAL NOT NULL DEFAULT 0.0,
            description TEXT,
            color TEXT DEFAULT '#667eea',
            created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
            updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
        )
    """)
    
    # B·∫£ng m·ªõi: L∆∞u c√°c ca l√†m vi·ªác (h·ªó tr·ª£ nhi·ªÅu ca/ng√†y)
    cursor.execute("""
        CREATE TABLE IF NOT EXISTS work_shifts (
            id INTEGER PRIMARY KEY AUTOINCREMENT,
            work_date DATE NOT NULL,
            shift_name TEXT DEFAULT 'Ca 1',
            job_id INTEGER,
            start_time TEXT NOT NULL,
            end_time TEXT NOT NULL,
            break_hours REAL DEFAULT 0.0,
            total_hours REAL NOT NULL,
            notes TEXT,
            created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
            updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
            FOREIGN KEY (job_id) REFERENCES jobs(id)
        )
    """)
    
    # Ki·ªÉm tra v√† th√™m c·ªôt job_id n·∫øu ch∆∞a c√≥ (migration)
    cursor.execute("PRAGMA table_info(work_shifts)")
    columns = [col[1] for col in cursor.fetchall()]
    if 'job_id' not in columns:
        cursor.execute("ALTER TABLE work_shifts ADD COLUMN job_id INTEGER")
    
    # B·∫£ng l∆∞u ng√†y ngh·ªâ l·ªÖ
    cursor.execute("""
        CREATE TABLE IF NOT EXISTS holidays (
            id INTEGER PRIMARY KEY AUTOINCREMENT,
            holiday_date DATE NOT NULL UNIQUE,
            description TEXT NOT NULL,
            created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
        )
    """)
    
    # B·∫£ng l∆∞u c√†i ƒë·∫∑t
    cursor.execute("""
        CREATE TABLE IF NOT EXISTS settings (
            key TEXT PRIMARY KEY,
            value TEXT NOT NULL,
            updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
        )
    """)
    
    # Th√™m c√†i ƒë·∫∑t m·∫∑c ƒë·ªãnh n·∫øu ch∆∞a c√≥
    default_settings = [
        ("standard_hours", "8.0"),
        ("break_hours", "1.0"),
        ("ot_rate", "1.5"),  # H·ªá s·ªë l∆∞∆°ng OT
    ]
    
    for key, value in default_settings:
        cursor.execute("""
            INSERT OR IGNORE INTO settings (key, value) VALUES (?, ?)
        """, (key, value))
    
    # Th√™m c√¥ng vi·ªác m·∫∑c ƒë·ªãnh n·∫øu ch∆∞a c√≥
    cursor.execute("SELECT COUNT(*) FROM jobs")
    if cursor.fetchone()[0] == 0:
        default_jobs = [
            ('B·ªánh vi·ªán', 1200, 'L√†m vi·ªác t·∫°i b·ªánh vi·ªán', '#EF4444'),
            ('Kombini', 1100, 'L√†m vi·ªác t·∫°i c·ª≠a h√†ng ti·ªán l·ª£i', '#3B82F6'),
            ('C√¥ng vi·ªác kh√°c', 1000, 'C√°c c√¥ng vi·ªác kh√°c', '#6B7280')
        ]
        
        for name, rate, desc, color in default_jobs:
            cursor.execute("""
                INSERT INTO jobs (job_name, hourly_rate, description, color) 
                VALUES (?, ?, ?, ?)
            """, (name, rate, desc, color))
    
    conn.commit()
    conn.close()


# C·ªù ƒë·ªÉ ki·ªÉm so√°t vi·ªác sync (tr√°nh sync qu√° nhi·ªÅu)
ENABLE_SYNC = True

def _sync_to_github():
    """ƒê·ªìng b·ªô database c·ªßa user hi·ªán t·∫°i l√™n GitHub (ch·∫°y background n·∫øu c√≥ th·ªÉ)."""
    if not ENABLE_SYNC:
        return
        
    try:
        import streamlit as st
        import github_sync
        
        if "user_info" in st.session_state and st.session_state["user_info"]:
            username = st.session_state["user_info"]["username"]
            # Ch·∫°y sync
            github_sync.sync_push_user_db(username)
    except Exception as e:
        print(f"Sync error: {e}")

# ==================== JOBS (C√¥ng vi·ªác v√† l∆∞∆°ng gi·ªù) ====================

def add_job(job_name: str, hourly_rate: float, description: str = "", color: str = "#667eea") -> int:
    """Th√™m c√¥ng vi·ªác m·ªõi. N·∫øu ƒë√£ t·ªìn t·∫°i, tr·∫£ v·ªÅ ID c·ªßa job ƒë√≥."""
    try:
        conn = get_connection()
        cursor = conn.cursor()
        
        # Ki·ªÉm tra xem job ƒë√£ t·ªìn t·∫°i ch∆∞a
        cursor.execute("SELECT id FROM jobs WHERE job_name = ?", (job_name,))
        existing = cursor.fetchone()
        
        if existing:
            # N·∫øu ƒë√£ t·ªìn t·∫°i, c·∫≠p nh·∫≠t l∆∞∆°ng v√† tr·∫£ v·ªÅ ID
            cursor.execute("""
                UPDATE jobs SET hourly_rate = ?, description = ?, updated_at = CURRENT_TIMESTAMP
                WHERE job_name = ?
            """, (hourly_rate, description, job_name))
            conn.commit()
            conn.close()
            clear_cache()
            _sync_to_github()  # Sync
            return existing[0]
        
        # Th√™m m·ªõi n·∫øu ch∆∞a t·ªìn t·∫°i
        cursor.execute("""
            INSERT INTO jobs (job_name, hourly_rate, description, color)
            VALUES (?, ?, ?, ?)
        """, (job_name, hourly_rate, description, color))
        
        job_id = cursor.lastrowid
        conn.commit()
        conn.close()
        clear_cache()
        _sync_to_github()  # Sync
        return job_id
    except Exception:
        return -1


def update_job(job_id: int, job_name: str, hourly_rate: float, description: str = "", color: str = "#667eea") -> bool:
    """C·∫≠p nh·∫≠t th√¥ng tin c√¥ng vi·ªác."""
    try:
        conn = get_connection()
        cursor = conn.cursor()
        
        cursor.execute("""
            UPDATE jobs SET
                job_name = ?,
                hourly_rate = ?,
                description = ?,
                color = ?,
                updated_at = CURRENT_TIMESTAMP
            WHERE id = ?
        """, (job_name, hourly_rate, description, color, job_id))
        
        conn.commit()
        conn.close()
        clear_cache()  # X√≥a cache khi c·∫≠p nh·∫≠t
        _sync_to_github()  # Sync
        return True
    except Exception:
        return False


def delete_job(job_id: int) -> bool:
    """X√≥a c√¥ng vi·ªác."""
    try:
        conn = get_connection()
        cursor = conn.cursor()
        
        cursor.execute("DELETE FROM jobs WHERE id = ?", (job_id,))
        
        conn.commit()
        conn.close()
        clear_cache()  # X√≥a cache khi x√≥a
        _sync_to_github()  # Sync
        return True
    except Exception:
        return False


def get_all_jobs() -> List[Dict]:
    """L·∫•y t·∫•t c·∫£ c√¥ng vi·ªác (c√≥ cache)."""
    cached = _get_cache('all_jobs')
    if cached is not None:
        return cached
    
    conn = get_connection()
    cursor = conn.cursor()
    
    cursor.execute("SELECT * FROM jobs ORDER BY job_name ASC")
    rows = cursor.fetchall()
    conn.close()
    
    result = [dict(row) for row in rows]
    _set_cache('all_jobs', result)
    return result


def get_job_by_id(job_id: int) -> Optional[Dict]:
    """L·∫•y th√¥ng tin m·ªôt c√¥ng vi·ªác."""
    conn = get_connection()
    cursor = conn.cursor()
    
    cursor.execute("SELECT * FROM jobs WHERE id = ?", (job_id,))
    row = cursor.fetchone()
    conn.close()
    
    if row:
        return dict(row)
    return None


def get_ot_rate() -> float:
    """L·∫•y h·ªá s·ªë l∆∞∆°ng OT."""
    value = get_setting("ot_rate")
    return float(value) if value else 1.5


def calculate_salary_by_month(year: int, month: int) -> Dict:
    """
    T√≠nh l∆∞∆°ng theo th√°ng, ph√¢n chia theo t·ª´ng c√¥ng vi·ªác.
    
    Returns:
        Dict v·ªõi th√¥ng tin l∆∞∆°ng theo t·ª´ng c√¥ng vi·ªác v√† t·ªïng l∆∞∆°ng
    """
    from datetime import timedelta
    
    start_date = date(year, month, 1)
    if month == 12:
        end_date = date(year + 1, 1, 1) - timedelta(days=1)
    else:
        end_date = date(year, month + 1, 1) - timedelta(days=1)
    
    conn = get_connection()
    cursor = conn.cursor()
    
    # L·∫•y t·∫•t c·∫£ ca l√†m vi·ªác trong th√°ng v·ªõi th√¥ng tin c√¥ng vi·ªác
    cursor.execute("""
        SELECT 
            ws.*, 
            j.job_name, 
            j.hourly_rate,
            j.color
        FROM work_shifts ws
        LEFT JOIN jobs j ON ws.job_id = j.id
        WHERE ws.work_date BETWEEN ? AND ?
        ORDER BY ws.work_date ASC
    """, (start_date.isoformat(), end_date.isoformat()))
    
    shifts = [dict(row) for row in cursor.fetchall()]
    conn.close()
    
    # L·∫•y c√†i ƒë·∫∑t
    standard_hours = get_standard_hours()
    ot_rate = get_ot_rate()
    
    # T√≠nh theo t·ª´ng c√¥ng vi·ªác
    job_salary = {}
    total_hours_all = 0
    total_salary_all = 0
    
    for shift in shifts:
        job_id = shift.get('job_id') or 0
        job_name = shift.get('job_name') or 'Ch∆∞a ph√¢n lo·∫°i'
        hourly_rate = shift.get('hourly_rate') or 0
        color = shift.get('color') or '#667eea'
        hours = shift['total_hours']
        
        if job_id not in job_salary:
            job_salary[job_id] = {
                'job_id': job_id,
                'job_name': job_name,
                'hourly_rate': hourly_rate,
                'color': color,
                'total_hours': 0,
                'shift_count': 0,
                'base_salary': 0
            }
        
        job_salary[job_id]['total_hours'] += hours
        job_salary[job_id]['shift_count'] += 1
        job_salary[job_id]['base_salary'] += hours * hourly_rate
        total_hours_all += hours
    
    # T√≠nh OT (t√≠nh theo t·ªïng gi·ªù ng√†y, kh√¥ng theo t·ª´ng ca)
    # L·∫•y t·ªïng gi·ªù theo ng√†y
    daily_hours = {}
    for shift in shifts:
        day = shift['work_date']
        if day not in daily_hours:
            daily_hours[day] = 0
        daily_hours[day] += shift['total_hours']
    
    total_ot_hours = 0
    for day, hours in daily_hours.items():
        if hours > standard_hours:
            total_ot_hours += hours - standard_hours
    
    # T√≠nh t·ªïng l∆∞∆°ng
    for job_id, data in job_salary.items():
        total_salary_all += data['base_salary']
    
    # Th√™m ti·ªÅn OT (t√≠nh d·ª±a tr√™n l∆∞∆°ng trung b√¨nh c√°c c√¥ng vi·ªác)
    if total_hours_all > 0 and total_salary_all > 0:
        avg_hourly_rate = total_salary_all / total_hours_all
        ot_bonus = total_ot_hours * avg_hourly_rate * (ot_rate - 1)  # Ph·∫ßn th∆∞·ªüng OT
    else:
        avg_hourly_rate = 0
        ot_bonus = 0
    
    return {
        'year': year,
        'month': month,
        'jobs': list(job_salary.values()),
        'total_hours': round(total_hours_all, 2),
        'total_ot_hours': round(total_ot_hours, 2),
        'total_days': len(daily_hours),
        'base_salary': round(total_salary_all, 0),
        'ot_bonus': round(ot_bonus, 0),
        'total_salary': round(total_salary_all + ot_bonus, 0),
        'ot_rate': ot_rate
    }


# ==================== WORK SHIFTS (Nhi·ªÅu ca/ng√†y) ====================

def add_work_shift(
    work_date: date,
    shift_name: str,
    start_time: str,
    end_time: str,
    break_hours: float,
    total_hours: float,
    notes: str = "",
    job_id: int = None
) -> int:
    """
    Th√™m m·ªôt ca l√†m vi·ªác m·ªõi.
    
    Args:
        work_date: Ng√†y l√†m vi·ªác
        shift_name: T√™n ca (v√≠ d·ª•: "Ca s√°ng", "Ca t·ªëi")
        start_time: Gi·ªù b·∫Øt ƒë·∫ßu (HH:MM)
        end_time: Gi·ªù k·∫øt th√∫c (HH:MM)
        break_hours: S·ªë gi·ªù ngh·ªâ
        total_hours: T·ªïng gi·ªù l√†m ca n√†y
        notes: Ghi ch√∫ (t√πy ch·ªçn)
        job_id: ID c√¥ng vi·ªác (t√πy ch·ªçn)
    
    Returns:
        ID c·ªßa ca l√†m vi·ªác m·ªõi, -1 n·∫øu l·ªói
    """
    try:
        conn = get_connection()
        cursor = conn.cursor()
        
        cursor.execute("""
            INSERT INTO work_shifts 
                (work_date, shift_name, job_id, start_time, end_time, break_hours, total_hours, notes)
            VALUES (?, ?, ?, ?, ?, ?, ?, ?)
        """, (work_date.isoformat(), shift_name, job_id, start_time, end_time, 
              break_hours, total_hours, notes))
        
        shift_id = cursor.lastrowid
        conn.commit()
        conn.close()
        _sync_to_github()  # Sync
        return shift_id
    except Exception as e:
        print(f"L·ªói khi th√™m ca l√†m vi·ªác: {e}")
        return -1


def update_work_shift(
    shift_id: int,
    shift_name: str,
    start_time: str,
    end_time: str,
    break_hours: float,
    total_hours: float,
    notes: str = ""
) -> bool:
    """C·∫≠p nh·∫≠t m·ªôt ca l√†m vi·ªác."""
    try:
        conn = get_connection()
        cursor = conn.cursor()
        
        cursor.execute("""
            UPDATE work_shifts SET
                shift_name = ?,
                start_time = ?,
                end_time = ?,
                break_hours = ?,
                total_hours = ?,
                notes = ?,
                updated_at = CURRENT_TIMESTAMP
            WHERE id = ?
        """, (shift_name, start_time, end_time, break_hours, total_hours, notes, shift_id))
        
        conn.commit()
        conn.close()
        _sync_to_github()  # Sync
        return True
    except Exception as e:
        print(f"L·ªói khi c·∫≠p nh·∫≠t ca l√†m vi·ªác: {e}")
        return False


def delete_work_shift(shift_id: int) -> bool:
    """X√≥a m·ªôt ca l√†m vi·ªác theo ID."""
    try:
        conn = get_connection()
        cursor = conn.cursor()
        
        cursor.execute("DELETE FROM work_shifts WHERE id = ?", (shift_id,))
        
        conn.commit()
        conn.close()
        _sync_to_github()  # Sync
        return True
    except Exception as e:
        print(f"L·ªói khi x√≥a ca l√†m vi·ªác: {e}")
        return False


def get_shifts_by_date(work_date: date) -> List[Dict]:
    """L·∫•y t·∫•t c·∫£ ca l√†m vi·ªác c·ªßa m·ªôt ng√†y."""
    conn = get_connection()
    cursor = conn.cursor()
    
    cursor.execute("""
        SELECT * FROM work_shifts 
        WHERE work_date = ?
        ORDER BY start_time ASC
    """, (work_date.isoformat(),))
    
    rows = cursor.fetchall()
    conn.close()
    
    return [dict(row) for row in rows]


def get_shift_by_id(shift_id: int) -> Optional[Dict]:
    """L·∫•y th√¥ng tin m·ªôt ca l√†m vi·ªác theo ID."""
    conn = get_connection()
    cursor = conn.cursor()
    
    cursor.execute("SELECT * FROM work_shifts WHERE id = ?", (shift_id,))
    
    row = cursor.fetchone()
    conn.close()
    
    if row:
        return dict(row)
    return None


def get_daily_summary(work_date: date, standard_hours: float = 8.0) -> Dict:
    """
    L·∫•y t·ªïng h·ª£p gi·ªù l√†m c·ªßa m·ªôt ng√†y (t·∫•t c·∫£ c√°c ca).
    
    Returns:
        Dict v·ªõi total_hours, overtime_hours, shift_count, shifts
    """
    shifts = get_shifts_by_date(work_date)
    
    if not shifts:
        return {
            "work_date": work_date.isoformat(),
            "total_hours": 0.0,
            "overtime_hours": 0.0,
            "shift_count": 0,
            "shifts": []
        }
    
    total_hours = sum(s['total_hours'] for s in shifts)
    overtime_hours = max(0, total_hours - standard_hours)
    
    return {
        "work_date": work_date.isoformat(),
        "total_hours": round(total_hours, 2),
        "overtime_hours": round(overtime_hours, 2),
        "shift_count": len(shifts),
        "shifts": shifts
    }


def get_shifts_by_range(start_date: date, end_date: date) -> List[Dict]:
    """L·∫•y t·∫•t c·∫£ ca l√†m vi·ªác trong kho·∫£ng th·ªùi gian."""
    conn = get_connection()
    cursor = conn.cursor()
    
    cursor.execute("""
        SELECT * FROM work_shifts 
        WHERE work_date BETWEEN ? AND ?
        ORDER BY work_date ASC, start_time ASC
    """, (start_date.isoformat(), end_date.isoformat()))
    
    rows = cursor.fetchall()
    conn.close()
    
    return [dict(row) for row in rows]


def get_daily_summaries_by_range(start_date: date, end_date: date, standard_hours: float = 8.0) -> List[Dict]:
    """
    L·∫•y t·ªïng h·ª£p gi·ªù l√†m theo ng√†y trong kho·∫£ng th·ªùi gian.
    G·ªôp c√°c ca trong c√πng m·ªôt ng√†y.
    """
    shifts = get_shifts_by_range(start_date, end_date)
    
    # G·ªôp theo ng√†y
    daily_data = {}
    for shift in shifts:
        work_date = shift['work_date']
        if work_date not in daily_data:
            daily_data[work_date] = {
                "work_date": work_date,
                "total_hours": 0.0,
                "shift_count": 0,
                "shifts": [],
                "start_time": shift['start_time'],  # Ca ƒë·∫ßu ti√™n
                "end_time": shift['end_time'],
                "break_hours": 0.0,
                "notes": ""
            }
        
        daily_data[work_date]["total_hours"] += shift['total_hours']
        daily_data[work_date]["break_hours"] += shift['break_hours']
        daily_data[work_date]["shift_count"] += 1
        daily_data[work_date]["shifts"].append(shift)
        daily_data[work_date]["end_time"] = shift['end_time']  # Ca cu·ªëi c√πng
        
        # G·ªôp notes
        if shift['notes']:
            if daily_data[work_date]["notes"]:
                daily_data[work_date]["notes"] += f"; {shift['notes']}"
            else:
                daily_data[work_date]["notes"] = shift['notes']
    
    # T√≠nh overtime cho m·ªói ng√†y
    result = []
    for work_date, data in daily_data.items():
        data["total_hours"] = round(data["total_hours"], 2)
        data["overtime_hours"] = round(max(0, data["total_hours"] - standard_hours), 2)
        result.append(data)
    
    # S·∫Øp x·∫øp theo ng√†y
    result.sort(key=lambda x: x["work_date"])
    return result


def get_daily_summaries_by_month(year: int, month: int, standard_hours: float = 8.0) -> List[Dict]:
    """L·∫•y t·ªïng h·ª£p gi·ªù l√†m theo ng√†y trong m·ªôt th√°ng."""
    start_date = date(year, month, 1)
    if month == 12:
        end_date = date(year + 1, 1, 1)
    else:
        end_date = date(year, month + 1, 1)
    
    from datetime import timedelta
    end_date = end_date - timedelta(days=1)
    
    return get_daily_summaries_by_range(start_date, end_date, standard_hours)


# ==================== WORK LOGS (T∆∞∆°ng th√≠ch ng∆∞·ª£c) ====================

def save_work_log(
    work_date: date,
    start_time: str,
    end_time: str,
    break_hours: float,
    total_hours: float,
    overtime_hours: float,
    notes: str = ""
) -> bool:
    """
    L∆∞u ho·∫∑c c·∫≠p nh·∫≠t gi·ªù l√†m cho m·ªôt ng√†y (t∆∞∆°ng th√≠ch ng∆∞·ª£c).
    Ph∆∞∆°ng th·ª©c n√†y s·∫Ω t·∫°o/c·∫≠p nh·∫≠t c·∫£ work_logs v√† work_shifts.
    """
    try:
        conn = get_connection()
        cursor = conn.cursor()
        
        # L∆∞u v√†o work_logs (t∆∞∆°ng th√≠ch ng∆∞·ª£c)
        cursor.execute("""
            INSERT INTO work_logs 
                (work_date, start_time, end_time, break_hours, total_hours, overtime_hours, notes)
            VALUES (?, ?, ?, ?, ?, ?, ?)
            ON CONFLICT(work_date) DO UPDATE SET
                start_time = excluded.start_time,
                end_time = excluded.end_time,
                break_hours = excluded.break_hours,
                total_hours = excluded.total_hours,
                overtime_hours = excluded.overtime_hours,
                notes = excluded.notes,
                updated_at = CURRENT_TIMESTAMP
        """, (work_date.isoformat(), start_time, end_time, break_hours, 
              total_hours, overtime_hours, notes))
        
        conn.commit()
        conn.close()
        return True
    except Exception as e:
        print(f"L·ªói khi l∆∞u gi·ªù l√†m: {e}")
        return False


def get_work_log(work_date: date) -> Optional[Dict]:
    """L·∫•y gi·ªù l√†m c·ªßa m·ªôt ng√†y c·ª• th·ªÉ (∆∞u ti√™n t·ª´ work_shifts n·∫øu c√≥)."""
    # Ki·ªÉm tra work_shifts tr∆∞·ªõc
    shifts = get_shifts_by_date(work_date)
    if shifts:
        standard_hours = get_standard_hours()
        summary = get_daily_summary(work_date, standard_hours)
        return {
            "work_date": work_date.isoformat(),
            "start_time": shifts[0]['start_time'],
            "end_time": shifts[-1]['end_time'],
            "break_hours": sum(s['break_hours'] for s in shifts),
            "total_hours": summary['total_hours'],
            "overtime_hours": summary['overtime_hours'],
            "notes": "; ".join(s['notes'] for s in shifts if s['notes']),
            "shift_count": len(shifts),
            "shifts": shifts
        }
    
    # Fallback: L·∫•y t·ª´ work_logs
    conn = get_connection()
    cursor = conn.cursor()
    
    cursor.execute("""
        SELECT * FROM work_logs WHERE work_date = ?
    """, (work_date.isoformat(),))
    
    row = cursor.fetchone()
    conn.close()
    
    if row:
        result = dict(row)
        result['shift_count'] = 1
        result['shifts'] = []
        return result
    return None


def get_work_logs_by_range(start_date: date, end_date: date) -> List[Dict]:
    """L·∫•y danh s√°ch gi·ªù l√†m trong kho·∫£ng th·ªùi gian (k·∫øt h·ª£p c·∫£ 2 b·∫£ng)."""
    standard_hours = get_standard_hours()
    
    # L·∫•y t·ª´ work_shifts (∆∞u ti√™n)
    daily_summaries = get_daily_summaries_by_range(start_date, end_date, standard_hours)
    shift_dates = {s['work_date'] for s in daily_summaries}
    
    # L·∫•y t·ª´ work_logs cho c√°c ng√†y ch∆∞a c√≥ trong shifts
    conn = get_connection()
    cursor = conn.cursor()
    
    cursor.execute("""
        SELECT * FROM work_logs 
        WHERE work_date BETWEEN ? AND ?
        ORDER BY work_date ASC
    """, (start_date.isoformat(), end_date.isoformat()))
    
    rows = cursor.fetchall()
    conn.close()
    
    # Th√™m c√°c ng√†y t·ª´ work_logs ch∆∞a c√≥ trong shifts
    for row in rows:
        if row['work_date'] not in shift_dates:
            log_dict = dict(row)
            log_dict['shift_count'] = 1
            daily_summaries.append(log_dict)
    
    # S·∫Øp x·∫øp l·∫°i
    daily_summaries.sort(key=lambda x: x['work_date'])
    return daily_summaries


def get_work_logs_by_month(year: int, month: int) -> List[Dict]:
    """L·∫•y danh s√°ch gi·ªù l√†m trong m·ªôt th√°ng."""
    start_date = date(year, month, 1)
    if month == 12:
        end_date = date(year + 1, 1, 1)
    else:
        end_date = date(year, month + 1, 1)
    
    from datetime import timedelta
    end_date = end_date - timedelta(days=1)
    
    return get_work_logs_by_range(start_date, end_date)


def delete_work_log(work_date: date) -> bool:
    """X√≥a gi·ªù l√†m c·ªßa m·ªôt ng√†y (c·∫£ work_logs v√† work_shifts)."""
    try:
        conn = get_connection()
        cursor = conn.cursor()
        
        # X√≥a t·ª´ work_logs
        cursor.execute("DELETE FROM work_logs WHERE work_date = ?", 
                      (work_date.isoformat(),))
        
        # X√≥a t·ª´ work_shifts
        cursor.execute("DELETE FROM work_shifts WHERE work_date = ?", 
                      (work_date.isoformat(),))
        
        conn.commit()
        conn.close()
        _sync_to_github()  # Sync
        return True
    except Exception as e:
        print(f"L·ªói khi x√≥a gi·ªù l√†m: {e}")
        return False


# ==================== HOLIDAYS ====================

def add_holiday(holiday_date: date, description: str) -> bool:
    """Th√™m ng√†y ngh·ªâ l·ªÖ."""
    try:
        conn = get_connection()
        cursor = conn.cursor()
        
        cursor.execute("""
            INSERT OR REPLACE INTO holidays (holiday_date, description)
            VALUES (?, ?)
        """, (holiday_date.isoformat(), description))
        
        conn.commit()
        conn.close()
        _sync_to_github()  # Sync
        return True
    except Exception as e:
        print(f"L·ªói khi th√™m ng√†y ngh·ªâ: {e}")
        return False


def remove_holiday(holiday_date: date) -> bool:
    """X√≥a ng√†y ngh·ªâ l·ªÖ."""
    try:
        conn = get_connection()
        cursor = conn.cursor()
        
        cursor.execute("DELETE FROM holidays WHERE holiday_date = ?", 
                      (holiday_date.isoformat(),))
        
        conn.commit()
        conn.close()
        _sync_to_github()  # Sync
        return True
    except Exception as e:
        print(f"L·ªói khi x√≥a ng√†y ngh·ªâ: {e}")
        return False


def get_all_holidays() -> List[Dict]:
    """L·∫•y t·∫•t c·∫£ ng√†y ngh·ªâ l·ªÖ."""
    conn = get_connection()
    cursor = conn.cursor()
    
    cursor.execute("SELECT * FROM holidays ORDER BY holiday_date ASC")
    rows = cursor.fetchall()
    conn.close()
    
    return [dict(row) for row in rows]


def get_holidays_by_year(year: int) -> List[Dict]:
    """L·∫•y ng√†y ngh·ªâ l·ªÖ trong m·ªôt nƒÉm."""
    conn = get_connection()
    cursor = conn.cursor()
    
    cursor.execute("""
        SELECT * FROM holidays 
        WHERE strftime('%Y', holiday_date) = ?
        ORDER BY holiday_date ASC
    """, (str(year),))
    
    rows = cursor.fetchall()
    conn.close()
    
    return [dict(row) for row in rows]


def is_holiday(check_date: date) -> Tuple[bool, str]:
    """Ki·ªÉm tra xem m·ªôt ng√†y c√≥ ph·∫£i ng√†y ngh·ªâ kh√¥ng."""
    conn = get_connection()
    cursor = conn.cursor()
    
    cursor.execute("""
        SELECT description FROM holidays WHERE holiday_date = ?
    """, (check_date.isoformat(),))
    
    row = cursor.fetchone()
    conn.close()
    
    if row:
        return True, row['description']
    return False, ""


# ==================== SETTINGS ====================

def get_setting(key: str) -> Optional[str]:
    """L·∫•y gi√° tr·ªã m·ªôt c√†i ƒë·∫∑t."""
    conn = get_connection()
    cursor = conn.cursor()
    
    cursor.execute("SELECT value FROM settings WHERE key = ?", (key,))
    row = cursor.fetchone()
    conn.close()
    
    if row:
        return row['value']
    return None


def get_all_settings() -> Dict[str, str]:
    """L·∫•y t·∫•t c·∫£ c√†i ƒë·∫∑t."""
    conn = get_connection()
    cursor = conn.cursor()
    
    cursor.execute("SELECT key, value FROM settings")
    rows = cursor.fetchall()
    conn.close()
    
    return {row['key']: row['value'] for row in rows}


def update_setting(key: str, value: str) -> bool:
    """C·∫≠p nh·∫≠t m·ªôt c√†i ƒë·∫∑t."""
    try:
        conn = get_connection()
        cursor = conn.cursor()
        
        cursor.execute("""
            INSERT INTO settings (key, value) VALUES (?, ?)
            ON CONFLICT(key) DO UPDATE SET 
                value = excluded.value,
                updated_at = CURRENT_TIMESTAMP
        """, (key, value))
        
        conn.commit()
        conn.close()
        _sync_to_github()  # Sync
        return True
    except Exception as e:
        print(f"L·ªói khi c·∫≠p nh·∫≠t c√†i ƒë·∫∑t: {e}")
        return False


def get_standard_hours() -> float:
    """L·∫•y s·ªë gi·ªù l√†m chu·∫©n."""
    value = get_setting("standard_hours")
    return float(value) if value else 8.0


def get_default_break_hours() -> float:
    """L·∫•y s·ªë gi·ªù ngh·ªâ m·∫∑c ƒë·ªãnh."""
    value = get_setting("break_hours")
    return float(value) if value else 1.0


# Note: Database kh·ªüi t·∫°o ƒë∆∞·ª£c g·ªçi trong app.py sau khi user ƒëƒÉng nh·∫≠p
# ƒë·ªÉ ƒë·∫£m b·∫£o s·ª≠ d·ª•ng ƒë√∫ng database path c·ªßa user


==================================================
FILE: calculations.py
==================================================
# -*- coding: utf-8 -*-
"""
Module t√≠nh to√°n gi·ªù l√†m vi·ªác v√† gi·ªù l√†m th√™m.
Bao g·ªìm c√°c h√†m validate v√† x·ª≠ l√Ω th·ªùi gian.
"""

from datetime import datetime, time, date, timedelta
from typing import Tuple, Optional, Dict, List
import pandas as pd


def parse_time(time_str: str) -> Optional[time]:
    """
    Chuy·ªÉn ƒë·ªïi chu·ªói th·ªùi gian th√†nh ƒë·ªëi t∆∞·ª£ng time.
    
    Args:
        time_str: Chu·ªói th·ªùi gian ƒë·ªãnh d·∫°ng "HH:MM"
    
    Returns:
        ƒê·ªëi t∆∞·ª£ng time ho·∫∑c None n·∫øu kh√¥ng h·ª£p l·ªá
    """
    try:
        return datetime.strptime(time_str, "%H:%M").time()
    except ValueError:
        return None


def time_to_hours(t: time) -> float:
    """Chuy·ªÉn ƒë·ªïi time th√†nh s·ªë gi·ªù (float)."""
    return t.hour + t.minute / 60.0


def validate_time_input(start_time: str, end_time: str, allow_overnight: bool = True) -> Tuple[bool, str]:
    """
    Ki·ªÉm tra ƒë·∫ßu v√†o th·ªùi gian c√≥ h·ª£p l·ªá kh√¥ng.
    
    Args:
        start_time: Gi·ªù b·∫Øt ƒë·∫ßu (HH:MM)
        end_time: Gi·ªù k·∫øt th√∫c (HH:MM)
        allow_overnight: Cho ph√©p ca qua ƒë√™m (gi·ªù k·∫øt th√∫c < gi·ªù b·∫Øt ƒë·∫ßu)
    
    Returns:
        Tuple (is_valid, error_message)
    """
    start = parse_time(start_time)
    end = parse_time(end_time)
    
    if start is None:
        return False, "‚ùå Gi·ªù b·∫Øt ƒë·∫ßu kh√¥ng h·ª£p l·ªá. Vui l√≤ng nh·∫≠p theo ƒë·ªãnh d·∫°ng HH:MM (v√≠ d·ª•: 08:00)"
    
    if end is None:
        return False, "‚ùå Gi·ªù k·∫øt th√∫c kh√¥ng h·ª£p l·ªá. Vui l√≤ng nh·∫≠p theo ƒë·ªãnh d·∫°ng HH:MM (v√≠ d·ª•: 17:00)"
    
    # N·∫øu kh√¥ng cho ph√©p ca qua ƒë√™m, ki·ªÉm tra th√¥ng th∆∞·ªùng
    if not allow_overnight and start >= end:
        return False, "‚ùå Gi·ªù b·∫Øt ƒë·∫ßu ph·∫£i s·ªõm h∆°n gi·ªù k·∫øt th√∫c!"
    
    # N·∫øu cho ph√©p ca qua ƒë√™m v√† start == end, b√°o l·ªói
    if start == end:
        return False, "‚ùå Gi·ªù b·∫Øt ƒë·∫ßu v√† gi·ªù k·∫øt th√∫c kh√¥ng th·ªÉ gi·ªëng nhau!"
    
    return True, ""


def calculate_work_hours(
    start_time: str, 
    end_time: str, 
    break_hours: float = 1.0
) -> Tuple[float, str]:
    """
    T√≠nh t·ªïng s·ªë gi·ªù l√†m vi·ªác.
    H·ªó tr·ª£ ca qua ƒë√™m (v√≠ d·ª•: 17:00 - 00:00 ho·∫∑c 22:00 - 06:00).
    
    Args:
        start_time: Gi·ªù b·∫Øt ƒë·∫ßu (HH:MM)
        end_time: Gi·ªù k·∫øt th√∫c (HH:MM)
        break_hours: S·ªë gi·ªù ngh·ªâ (m·∫∑c ƒë·ªãnh 1 gi·ªù)
    
    Returns:
        Tuple (total_hours, error_message)
        total_hours = -1 n·∫øu c√≥ l·ªói
    """
    is_valid, error_msg = validate_time_input(start_time, end_time)
    if not is_valid:
        return -1, error_msg
    
    start = parse_time(start_time)
    end = parse_time(end_time)
    
    # T√≠nh t·ªïng gi·ªù l√†m
    start_hours = time_to_hours(start)
    end_hours = time_to_hours(end)
    
    # X·ª≠ l√Ω ca qua ƒë√™m (end_hours < start_hours)
    if end_hours <= start_hours:
        # V√≠ d·ª•: 17:00 - 00:00 => 17 - 24 = 7 gi·ªù
        # V√≠ d·ª•: 22:00 - 06:00 => 22 - 30 = 8 gi·ªù
        end_hours += 24
    
    total_hours = end_hours - start_hours - break_hours
    
    if total_hours < 0:
        return -1, "‚ùå T·ªïng gi·ªù l√†m kh√¥ng th·ªÉ √¢m. Vui l√≤ng ki·ªÉm tra l·∫°i gi·ªù ngh·ªâ!"
    
    return round(total_hours, 2), ""


def calculate_overtime(
    total_hours: float, 
    standard_hours: float = 8.0
) -> float:
    """
    T√≠nh gi·ªù l√†m th√™m.
    
    Args:
        total_hours: T·ªïng gi·ªù l√†m th·ª±c t·∫ø
        standard_hours: Gi·ªù l√†m chu·∫©n (m·∫∑c ƒë·ªãnh 8 gi·ªù)
    
    Returns:
        S·ªë gi·ªù l√†m th√™m (0 n·∫øu kh√¥ng c√≥ OT)
    """
    overtime = total_hours - standard_hours
    return round(max(0, overtime), 2)


def calculate_full(
    start_time: str,
    end_time: str,
    break_hours: float = 1.0,
    standard_hours: float = 8.0
) -> Dict:
    """
    T√≠nh to√°n ƒë·∫ßy ƒë·ªß gi·ªù l√†m v√† gi·ªù l√†m th√™m.
    
    Returns:
        Dict v·ªõi c√°c key: success, total_hours, overtime_hours, error_message
    """
    result = {
        "success": False,
        "total_hours": 0.0,
        "overtime_hours": 0.0,
        "error_message": ""
    }
    
    total_hours, error = calculate_work_hours(start_time, end_time, break_hours)
    
    if total_hours < 0:
        result["error_message"] = error
        return result
    
    overtime = calculate_overtime(total_hours, standard_hours)
    
    result["success"] = True
    result["total_hours"] = total_hours
    result["overtime_hours"] = overtime
    
    return result


def format_hours(hours: float) -> str:
    """
    Format s·ªë gi·ªù th√†nh chu·ªói d·ªÖ ƒë·ªçc.
    
    Args:
        hours: S·ªë gi·ªù (float)
    
    Returns:
        Chu·ªói ƒë·ªãnh d·∫°ng "X gi·ªù Y ph√∫t"
    """
    h = int(hours)
    m = int((hours - h) * 60)
    
    if m == 0:
        return f"{h} gi·ªù"
    return f"{h} gi·ªù {m} ph√∫t"


def generate_report(work_logs: List[Dict], standard_hours: float = 8.0) -> Dict:
    """
    T·∫°o b√°o c√°o t·ª´ danh s√°ch gi·ªù l√†m.
    
    Args:
        work_logs: Danh s√°ch dict ch·ª©a th√¥ng tin gi·ªù l√†m
        standard_hours: Gi·ªù l√†m chu·∫©n
    
    Returns:
        Dict ch·ª©a th·ªëng k√™ b√°o c√°o
    """
    if not work_logs:
        return {
            "total_days": 0,
            "total_hours": 0.0,
            "total_overtime": 0.0,
            "average_hours": 0.0,
            "days_with_overtime": 0,
            "max_overtime_day": None,
            "max_overtime_hours": 0.0
        }
    
    df = pd.DataFrame(work_logs)
    
    total_days = len(df)
    total_hours = df['total_hours'].sum()
    total_overtime = df['overtime_hours'].sum()
    average_hours = total_hours / total_days if total_days > 0 else 0
    days_with_overtime = len(df[df['overtime_hours'] > 0])
    
    # Ng√†y c√≥ OT nhi·ªÅu nh·∫•t
    max_idx = df['overtime_hours'].idxmax()
    max_overtime_day = df.loc[max_idx, 'work_date'] if df.loc[max_idx, 'overtime_hours'] > 0 else None
    max_overtime_hours = df['overtime_hours'].max()
    
    return {
        "total_days": total_days,
        "total_hours": round(total_hours, 2),
        "total_overtime": round(total_overtime, 2),
        "average_hours": round(average_hours, 2),
        "days_with_overtime": days_with_overtime,
        "max_overtime_day": max_overtime_day,
        "max_overtime_hours": round(max_overtime_hours, 2)
    }


def get_week_dates(target_date: date) -> Tuple[date, date]:
    """
    L·∫•y ng√†y ƒë·∫ßu tu·∫ßn v√† cu·ªëi tu·∫ßn c·ªßa m·ªôt ng√†y.
    
    Returns:
        Tuple (monday, sunday)
    """
    monday = target_date - timedelta(days=target_date.weekday())
    sunday = monday + timedelta(days=6)
    return monday, sunday


def get_month_dates(year: int, month: int) -> Tuple[date, date]:
    """
    L·∫•y ng√†y ƒë·∫ßu th√°ng v√† cu·ªëi th√°ng.
    
    Returns:
        Tuple (first_day, last_day)
    """
    first_day = date(year, month, 1)
    
    if month == 12:
        next_month = date(year + 1, 1, 1)
    else:
        next_month = date(year, month + 1, 1)
    
    last_day = next_month - timedelta(days=1)
    
    return first_day, last_day


==================================================
FILE: requirements.txt
==================================================
Ôªøstreamlit>=1.28.0
pandas>=2.0.0
plotly>=5.18.0
openpyxl>=3.1.0
supabase>=2.0.0
extra-streamlit-components>=0.1.0

